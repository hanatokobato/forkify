import { gql } from '@apollo/client';
import * as Apollo from '@apollo/client';
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
const defaultOptions = {} as const;
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  bigint: any;
  numeric: any;
  timestamp: any;
};

/** Autogenerated input type of AddToCart */
export type AddToCartInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  productId: Scalars['Int'];
};

/** Autogenerated return type of AddToCart */
export type AddToCartPayload = {
  __typename?: 'AddToCartPayload';
  cart: Cart;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
};

export type Address = {
  __typename?: 'Address';
  id: Scalars['ID'];
};

/** Boolean expression to compare columns of type "Boolean". All fields are combined with logical 'AND'. */
export type Boolean_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Boolean']>;
  _gt?: InputMaybe<Scalars['Boolean']>;
  _gte?: InputMaybe<Scalars['Boolean']>;
  _in?: InputMaybe<Array<Scalars['Boolean']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Boolean']>;
  _lte?: InputMaybe<Scalars['Boolean']>;
  _neq?: InputMaybe<Scalars['Boolean']>;
  _nin?: InputMaybe<Array<Scalars['Boolean']>>;
};

export type Cart = {
  __typename?: 'Cart';
  id: Scalars['Int'];
  lineItems?: Maybe<Array<LineItem>>;
  subtotal: Scalars['Float'];
  totalItems: Scalars['Int'];
};

/** Autogenerated input type of CreateAddress */
export type CreateAddressInput = {
  address1: Scalars['String'];
  city: Scalars['String'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  countryId: Scalars['Int'];
  default: Scalars['Boolean'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  orderId?: InputMaybe<Scalars['Int']>;
  shoppingAddressId?: InputMaybe<Scalars['Int']>;
  stateId: Scalars['Int'];
  zipCode: Scalars['String'];
};

/** Autogenerated return type of CreateAddress */
export type CreateAddressPayload = {
  __typename?: 'CreateAddressPayload';
  address?: Maybe<Address>;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Scalars['String']>>;
};

/** Autogenerated input type of CreateOrder */
export type CreateOrderInput = {
  cartId: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
};

/** Autogenerated return type of CreateOrder */
export type CreateOrderPayload = {
  __typename?: 'CreateOrderPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors?: Maybe<Array<Scalars['String']>>;
  order?: Maybe<Order>;
};

/** Autogenerated input type of CreateProduct */
export type CreateProductInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  images: Array<ImageInput>;
  name: Scalars['String'];
  price: Scalars['Float'];
  quantity: Scalars['Int'];
};

/** Autogenerated return type of CreateProduct */
export type CreateProductPayload = {
  __typename?: 'CreateProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  product?: Maybe<Product>;
};

/** Autogenerated input type of DeleteProduct */
export type DeleteProductInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteProduct */
export type DeleteProductPayload = {
  __typename?: 'DeleteProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of DeleteShippingZone */
export type DeleteShippingZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  id: Scalars['ID'];
};

/** Autogenerated return type of DeleteShippingZone */
export type DeleteShippingZonePayload = {
  __typename?: 'DeleteShippingZonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  id: Scalars['ID'];
};

export type Image = {
  __typename?: 'Image';
  id: Scalars['ID'];
  photoLink: Scalars['String'];
};

export type ImageInput = {
  photoLink: Scalars['String'];
};

/** Boolean expression to compare columns of type "Int". All fields are combined with logical 'AND'. */
export type Int_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['Int']>;
  _gt?: InputMaybe<Scalars['Int']>;
  _gte?: InputMaybe<Scalars['Int']>;
  _in?: InputMaybe<Array<Scalars['Int']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['Int']>;
  _lte?: InputMaybe<Scalars['Int']>;
  _neq?: InputMaybe<Scalars['Int']>;
  _nin?: InputMaybe<Array<Scalars['Int']>>;
};

export type LineItem = {
  __typename?: 'LineItem';
  id: Scalars['ID'];
  lineTotal: Scalars['Float'];
  name: Scalars['String'];
  photo?: Maybe<Scalars['String']>;
  quantity: Scalars['Int'];
};

export type Order = {
  __typename?: 'Order';
  id: Scalars['ID'];
  number?: Maybe<Scalars['String']>;
};

export type Product = {
  __typename?: 'Product';
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  images?: Maybe<Array<Image>>;
  name?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Int']>;
};

/** Autogenerated input type of SettingShippingZone */
export type SettingShippingZoneInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  countryIds: Array<Scalars['Int']>;
  name: Scalars['String'];
  shippingRates: Array<ShippingRateInput>;
};

/** Autogenerated return type of SettingShippingZone */
export type SettingShippingZonePayload = {
  __typename?: 'SettingShippingZonePayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  shippingZone?: Maybe<ShippingZone>;
};

export type ShippingOption = {
  __typename?: 'ShippingOption';
  description?: Maybe<Scalars['String']>;
  price?: Maybe<Scalars['Float']>;
  shippingRateId: Scalars['ID'];
};

export type ShippingRateInput = {
  amount: Scalars['Float'];
  name: Scalars['String'];
};

export type ShippingZone = {
  __typename?: 'ShippingZone';
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
};

/** Boolean expression to compare columns of type "String". All fields are combined with logical 'AND'. */
export type String_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['String']>;
  _gt?: InputMaybe<Scalars['String']>;
  _gte?: InputMaybe<Scalars['String']>;
  /** does the column match the given case-insensitive pattern */
  _ilike?: InputMaybe<Scalars['String']>;
  _in?: InputMaybe<Array<Scalars['String']>>;
  /** does the column match the given POSIX regular expression, case insensitive */
  _iregex?: InputMaybe<Scalars['String']>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  /** does the column match the given pattern */
  _like?: InputMaybe<Scalars['String']>;
  _lt?: InputMaybe<Scalars['String']>;
  _lte?: InputMaybe<Scalars['String']>;
  _neq?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given case-insensitive pattern */
  _nilike?: InputMaybe<Scalars['String']>;
  _nin?: InputMaybe<Array<Scalars['String']>>;
  /** does the column NOT match the given POSIX regular expression, case insensitive */
  _niregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given pattern */
  _nlike?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given POSIX regular expression, case sensitive */
  _nregex?: InputMaybe<Scalars['String']>;
  /** does the column NOT match the given SQL regular expression */
  _nsimilar?: InputMaybe<Scalars['String']>;
  /** does the column match the given POSIX regular expression, case sensitive */
  _regex?: InputMaybe<Scalars['String']>;
  /** does the column match the given SQL regular expression */
  _similar?: InputMaybe<Scalars['String']>;
};

/** Autogenerated input type of UpdateCartQty */
export type UpdateCartQtyInput = {
  adjustQty: Scalars['Int'];
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  itemId: Scalars['Int'];
};

/** Autogenerated return type of UpdateCartQty */
export type UpdateCartQtyPayload = {
  __typename?: 'UpdateCartQtyPayload';
  cart: Cart;
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
};

/** Autogenerated input type of UpdateProduct */
export type UpdateProductInput = {
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: InputMaybe<Scalars['String']>;
  description: Scalars['String'];
  id: Scalars['ID'];
  images: Array<ImageInput>;
  name: Scalars['String'];
  price: Scalars['Float'];
  quantity: Scalars['Int'];
};

/** Autogenerated return type of UpdateProduct */
export type UpdateProductPayload = {
  __typename?: 'UpdateProductPayload';
  /** A unique identifier for the client performing the mutation. */
  clientMutationId?: Maybe<Scalars['String']>;
  errors: Array<Scalars['String']>;
  product?: Maybe<Product>;
};

/** columns and relationships of "addresses" */
export type Addresses = {
  __typename?: 'addresses';
  address1?: Maybe<Scalars['String']>;
  address_type?: Maybe<Scalars['Int']>;
  addressable_id?: Maybe<Scalars['Int']>;
  addressable_type?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country_id?: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamp'];
  first_name?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  is_billing_default?: Maybe<Scalars['Boolean']>;
  is_default?: Maybe<Scalars['Boolean']>;
  last_name?: Maybe<Scalars['String']>;
  /** An object relationship */
  state?: Maybe<States>;
  state_id?: Maybe<Scalars['Int']>;
  updated_at: Scalars['timestamp'];
  zip_code?: Maybe<Scalars['String']>;
};

/** aggregated selection of "addresses" */
export type Addresses_Aggregate = {
  __typename?: 'addresses_aggregate';
  aggregate?: Maybe<Addresses_Aggregate_Fields>;
  nodes: Array<Addresses>;
};

/** aggregate fields of "addresses" */
export type Addresses_Aggregate_Fields = {
  __typename?: 'addresses_aggregate_fields';
  avg?: Maybe<Addresses_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Addresses_Max_Fields>;
  min?: Maybe<Addresses_Min_Fields>;
  stddev?: Maybe<Addresses_Stddev_Fields>;
  stddev_pop?: Maybe<Addresses_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Addresses_Stddev_Samp_Fields>;
  sum?: Maybe<Addresses_Sum_Fields>;
  var_pop?: Maybe<Addresses_Var_Pop_Fields>;
  var_samp?: Maybe<Addresses_Var_Samp_Fields>;
  variance?: Maybe<Addresses_Variance_Fields>;
};


/** aggregate fields of "addresses" */
export type Addresses_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Addresses_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Addresses_Avg_Fields = {
  __typename?: 'addresses_avg_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "addresses". All fields are combined with a logical 'AND'. */
export type Addresses_Bool_Exp = {
  _and?: InputMaybe<Array<Addresses_Bool_Exp>>;
  _not?: InputMaybe<Addresses_Bool_Exp>;
  _or?: InputMaybe<Array<Addresses_Bool_Exp>>;
  address1?: InputMaybe<String_Comparison_Exp>;
  address_type?: InputMaybe<Int_Comparison_Exp>;
  addressable_id?: InputMaybe<Int_Comparison_Exp>;
  addressable_type?: InputMaybe<String_Comparison_Exp>;
  city?: InputMaybe<String_Comparison_Exp>;
  country_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  first_name?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  is_billing_default?: InputMaybe<Boolean_Comparison_Exp>;
  is_default?: InputMaybe<Boolean_Comparison_Exp>;
  last_name?: InputMaybe<String_Comparison_Exp>;
  state?: InputMaybe<States_Bool_Exp>;
  state_id?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  zip_code?: InputMaybe<String_Comparison_Exp>;
};

/** unique or primary key constraints on table "addresses" */
export enum Addresses_Constraint {
  /** unique or primary key constraint */
  AddressesPkey = 'addresses_pkey'
}

/** input type for incrementing numeric columns in table "addresses" */
export type Addresses_Inc_Input = {
  address_type?: InputMaybe<Scalars['Int']>;
  addressable_id?: InputMaybe<Scalars['Int']>;
  country_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  state_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "addresses" */
export type Addresses_Insert_Input = {
  address1?: InputMaybe<Scalars['String']>;
  address_type?: InputMaybe<Scalars['Int']>;
  addressable_id?: InputMaybe<Scalars['Int']>;
  addressable_type?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  country_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  first_name?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  is_billing_default?: InputMaybe<Scalars['Boolean']>;
  is_default?: InputMaybe<Scalars['Boolean']>;
  last_name?: InputMaybe<Scalars['String']>;
  state?: InputMaybe<States_Obj_Rel_Insert_Input>;
  state_id?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  zip_code?: InputMaybe<Scalars['String']>;
};

/** aggregate max on columns */
export type Addresses_Max_Fields = {
  __typename?: 'addresses_max_fields';
  address1?: Maybe<Scalars['String']>;
  address_type?: Maybe<Scalars['Int']>;
  addressable_id?: Maybe<Scalars['Int']>;
  addressable_type?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  last_name?: Maybe<Scalars['String']>;
  state_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  zip_code?: Maybe<Scalars['String']>;
};

/** aggregate min on columns */
export type Addresses_Min_Fields = {
  __typename?: 'addresses_min_fields';
  address1?: Maybe<Scalars['String']>;
  address_type?: Maybe<Scalars['Int']>;
  addressable_id?: Maybe<Scalars['Int']>;
  addressable_type?: Maybe<Scalars['String']>;
  city?: Maybe<Scalars['String']>;
  country_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  first_name?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  last_name?: Maybe<Scalars['String']>;
  state_id?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  zip_code?: Maybe<Scalars['String']>;
};

/** response of any mutation on the table "addresses" */
export type Addresses_Mutation_Response = {
  __typename?: 'addresses_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Addresses>;
};

/** on_conflict condition type for table "addresses" */
export type Addresses_On_Conflict = {
  constraint: Addresses_Constraint;
  update_columns?: Array<Addresses_Update_Column>;
  where?: InputMaybe<Addresses_Bool_Exp>;
};

/** Ordering options when selecting data from "addresses". */
export type Addresses_Order_By = {
  address1?: InputMaybe<Order_By>;
  address_type?: InputMaybe<Order_By>;
  addressable_id?: InputMaybe<Order_By>;
  addressable_type?: InputMaybe<Order_By>;
  city?: InputMaybe<Order_By>;
  country_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  first_name?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  is_billing_default?: InputMaybe<Order_By>;
  is_default?: InputMaybe<Order_By>;
  last_name?: InputMaybe<Order_By>;
  state?: InputMaybe<States_Order_By>;
  state_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  zip_code?: InputMaybe<Order_By>;
};

/** primary key columns input for table: addresses */
export type Addresses_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "addresses" */
export enum Addresses_Select_Column {
  /** column name */
  Address1 = 'address1',
  /** column name */
  AddressType = 'address_type',
  /** column name */
  AddressableId = 'addressable_id',
  /** column name */
  AddressableType = 'addressable_type',
  /** column name */
  City = 'city',
  /** column name */
  CountryId = 'country_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsBillingDefault = 'is_billing_default',
  /** column name */
  IsDefault = 'is_default',
  /** column name */
  LastName = 'last_name',
  /** column name */
  StateId = 'state_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ZipCode = 'zip_code'
}

/** input type for updating data in table "addresses" */
export type Addresses_Set_Input = {
  address1?: InputMaybe<Scalars['String']>;
  address_type?: InputMaybe<Scalars['Int']>;
  addressable_id?: InputMaybe<Scalars['Int']>;
  addressable_type?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  country_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  first_name?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  is_billing_default?: InputMaybe<Scalars['Boolean']>;
  is_default?: InputMaybe<Scalars['Boolean']>;
  last_name?: InputMaybe<Scalars['String']>;
  state_id?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  zip_code?: InputMaybe<Scalars['String']>;
};

/** aggregate stddev on columns */
export type Addresses_Stddev_Fields = {
  __typename?: 'addresses_stddev_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Addresses_Stddev_Pop_Fields = {
  __typename?: 'addresses_stddev_pop_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Addresses_Stddev_Samp_Fields = {
  __typename?: 'addresses_stddev_samp_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Addresses_Sum_Fields = {
  __typename?: 'addresses_sum_fields';
  address_type?: Maybe<Scalars['Int']>;
  addressable_id?: Maybe<Scalars['Int']>;
  country_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  state_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "addresses" */
export enum Addresses_Update_Column {
  /** column name */
  Address1 = 'address1',
  /** column name */
  AddressType = 'address_type',
  /** column name */
  AddressableId = 'addressable_id',
  /** column name */
  AddressableType = 'addressable_type',
  /** column name */
  City = 'city',
  /** column name */
  CountryId = 'country_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  FirstName = 'first_name',
  /** column name */
  Id = 'id',
  /** column name */
  IsBillingDefault = 'is_billing_default',
  /** column name */
  IsDefault = 'is_default',
  /** column name */
  LastName = 'last_name',
  /** column name */
  StateId = 'state_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  ZipCode = 'zip_code'
}

/** aggregate var_pop on columns */
export type Addresses_Var_Pop_Fields = {
  __typename?: 'addresses_var_pop_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Addresses_Var_Samp_Fields = {
  __typename?: 'addresses_var_samp_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Addresses_Variance_Fields = {
  __typename?: 'addresses_variance_fields';
  address_type?: Maybe<Scalars['Float']>;
  addressable_id?: Maybe<Scalars['Float']>;
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  state_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to compare columns of type "bigint". All fields are combined with logical 'AND'. */
export type Bigint_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['bigint']>;
  _gt?: InputMaybe<Scalars['bigint']>;
  _gte?: InputMaybe<Scalars['bigint']>;
  _in?: InputMaybe<Array<Scalars['bigint']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['bigint']>;
  _lte?: InputMaybe<Scalars['bigint']>;
  _neq?: InputMaybe<Scalars['bigint']>;
  _nin?: InputMaybe<Array<Scalars['bigint']>>;
};

/** columns and relationships of "cart_items" */
export type Cart_Items = {
  __typename?: 'cart_items';
  active?: Maybe<Scalars['Boolean']>;
  cart_id?: Maybe<Scalars['Int']>;
  created_at: Scalars['timestamp'];
  id: Scalars['bigint'];
  item_type_id: Scalars['Int'];
  product_id?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
  updated_at: Scalars['timestamp'];
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregated selection of "cart_items" */
export type Cart_Items_Aggregate = {
  __typename?: 'cart_items_aggregate';
  aggregate?: Maybe<Cart_Items_Aggregate_Fields>;
  nodes: Array<Cart_Items>;
};

/** aggregate fields of "cart_items" */
export type Cart_Items_Aggregate_Fields = {
  __typename?: 'cart_items_aggregate_fields';
  avg?: Maybe<Cart_Items_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Cart_Items_Max_Fields>;
  min?: Maybe<Cart_Items_Min_Fields>;
  stddev?: Maybe<Cart_Items_Stddev_Fields>;
  stddev_pop?: Maybe<Cart_Items_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Cart_Items_Stddev_Samp_Fields>;
  sum?: Maybe<Cart_Items_Sum_Fields>;
  var_pop?: Maybe<Cart_Items_Var_Pop_Fields>;
  var_samp?: Maybe<Cart_Items_Var_Samp_Fields>;
  variance?: Maybe<Cart_Items_Variance_Fields>;
};


/** aggregate fields of "cart_items" */
export type Cart_Items_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Cart_Items_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Cart_Items_Avg_Fields = {
  __typename?: 'cart_items_avg_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "cart_items". All fields are combined with a logical 'AND'. */
export type Cart_Items_Bool_Exp = {
  _and?: InputMaybe<Array<Cart_Items_Bool_Exp>>;
  _not?: InputMaybe<Cart_Items_Bool_Exp>;
  _or?: InputMaybe<Array<Cart_Items_Bool_Exp>>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  cart_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  item_type_id?: InputMaybe<Int_Comparison_Exp>;
  product_id?: InputMaybe<Int_Comparison_Exp>;
  quantity?: InputMaybe<Int_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  user_id?: InputMaybe<Int_Comparison_Exp>;
};

/** unique or primary key constraints on table "cart_items" */
export enum Cart_Items_Constraint {
  /** unique or primary key constraint */
  CartItemsPkey = 'cart_items_pkey'
}

/** input type for incrementing numeric columns in table "cart_items" */
export type Cart_Items_Inc_Input = {
  cart_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  item_type_id?: InputMaybe<Scalars['Int']>;
  product_id?: InputMaybe<Scalars['Int']>;
  quantity?: InputMaybe<Scalars['Int']>;
  user_id?: InputMaybe<Scalars['Int']>;
};

/** input type for inserting data into table "cart_items" */
export type Cart_Items_Insert_Input = {
  active?: InputMaybe<Scalars['Boolean']>;
  cart_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  item_type_id?: InputMaybe<Scalars['Int']>;
  product_id?: InputMaybe<Scalars['Int']>;
  quantity?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  user_id?: InputMaybe<Scalars['Int']>;
};

/** aggregate max on columns */
export type Cart_Items_Max_Fields = {
  __typename?: 'cart_items_max_fields';
  cart_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  item_type_id?: Maybe<Scalars['Int']>;
  product_id?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** aggregate min on columns */
export type Cart_Items_Min_Fields = {
  __typename?: 'cart_items_min_fields';
  cart_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  item_type_id?: Maybe<Scalars['Int']>;
  product_id?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** response of any mutation on the table "cart_items" */
export type Cart_Items_Mutation_Response = {
  __typename?: 'cart_items_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Cart_Items>;
};

/** on_conflict condition type for table "cart_items" */
export type Cart_Items_On_Conflict = {
  constraint: Cart_Items_Constraint;
  update_columns?: Array<Cart_Items_Update_Column>;
  where?: InputMaybe<Cart_Items_Bool_Exp>;
};

/** Ordering options when selecting data from "cart_items". */
export type Cart_Items_Order_By = {
  active?: InputMaybe<Order_By>;
  cart_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  item_type_id?: InputMaybe<Order_By>;
  product_id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: cart_items */
export type Cart_Items_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "cart_items" */
export enum Cart_Items_Select_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CartId = 'cart_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ItemTypeId = 'item_type_id',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "cart_items" */
export type Cart_Items_Set_Input = {
  active?: InputMaybe<Scalars['Boolean']>;
  cart_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  item_type_id?: InputMaybe<Scalars['Int']>;
  product_id?: InputMaybe<Scalars['Int']>;
  quantity?: InputMaybe<Scalars['Int']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  user_id?: InputMaybe<Scalars['Int']>;
};

/** aggregate stddev on columns */
export type Cart_Items_Stddev_Fields = {
  __typename?: 'cart_items_stddev_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Cart_Items_Stddev_Pop_Fields = {
  __typename?: 'cart_items_stddev_pop_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Cart_Items_Stddev_Samp_Fields = {
  __typename?: 'cart_items_stddev_samp_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Cart_Items_Sum_Fields = {
  __typename?: 'cart_items_sum_fields';
  cart_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  item_type_id?: Maybe<Scalars['Int']>;
  product_id?: Maybe<Scalars['Int']>;
  quantity?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['Int']>;
};

/** update columns of table "cart_items" */
export enum Cart_Items_Update_Column {
  /** column name */
  Active = 'active',
  /** column name */
  CartId = 'cart_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ItemTypeId = 'item_type_id',
  /** column name */
  ProductId = 'product_id',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** aggregate var_pop on columns */
export type Cart_Items_Var_Pop_Fields = {
  __typename?: 'cart_items_var_pop_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Cart_Items_Var_Samp_Fields = {
  __typename?: 'cart_items_var_samp_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Cart_Items_Variance_Fields = {
  __typename?: 'cart_items_variance_fields';
  cart_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  item_type_id?: Maybe<Scalars['Float']>;
  product_id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "countries" */
export type Countries = {
  __typename?: 'countries';
  abbreviation?: Maybe<Scalars['String']>;
  active?: Maybe<Scalars['Boolean']>;
  created_at: Scalars['timestamp'];
  id: Scalars['bigint'];
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  /** An array relationship */
  states: Array<States>;
  /** An aggregate relationship */
  states_aggregate: States_Aggregate;
  updated_at: Scalars['timestamp'];
};


/** columns and relationships of "countries" */
export type CountriesStatesArgs = {
  distinct_on?: InputMaybe<Array<States_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<States_Order_By>>;
  where?: InputMaybe<States_Bool_Exp>;
};


/** columns and relationships of "countries" */
export type CountriesStates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<States_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<States_Order_By>>;
  where?: InputMaybe<States_Bool_Exp>;
};

/** aggregated selection of "countries" */
export type Countries_Aggregate = {
  __typename?: 'countries_aggregate';
  aggregate?: Maybe<Countries_Aggregate_Fields>;
  nodes: Array<Countries>;
};

/** aggregate fields of "countries" */
export type Countries_Aggregate_Fields = {
  __typename?: 'countries_aggregate_fields';
  avg?: Maybe<Countries_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Countries_Max_Fields>;
  min?: Maybe<Countries_Min_Fields>;
  stddev?: Maybe<Countries_Stddev_Fields>;
  stddev_pop?: Maybe<Countries_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Countries_Stddev_Samp_Fields>;
  sum?: Maybe<Countries_Sum_Fields>;
  var_pop?: Maybe<Countries_Var_Pop_Fields>;
  var_samp?: Maybe<Countries_Var_Samp_Fields>;
  variance?: Maybe<Countries_Variance_Fields>;
};


/** aggregate fields of "countries" */
export type Countries_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Countries_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "countries" */
export type Countries_Aggregate_Order_By = {
  avg?: InputMaybe<Countries_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Countries_Max_Order_By>;
  min?: InputMaybe<Countries_Min_Order_By>;
  stddev?: InputMaybe<Countries_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Countries_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Countries_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Countries_Sum_Order_By>;
  var_pop?: InputMaybe<Countries_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Countries_Var_Samp_Order_By>;
  variance?: InputMaybe<Countries_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "countries" */
export type Countries_Arr_Rel_Insert_Input = {
  data: Array<Countries_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};

/** aggregate avg on columns */
export type Countries_Avg_Fields = {
  __typename?: 'countries_avg_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "countries" */
export type Countries_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "countries". All fields are combined with a logical 'AND'. */
export type Countries_Bool_Exp = {
  _and?: InputMaybe<Array<Countries_Bool_Exp>>;
  _not?: InputMaybe<Countries_Bool_Exp>;
  _or?: InputMaybe<Array<Countries_Bool_Exp>>;
  abbreviation?: InputMaybe<String_Comparison_Exp>;
  active?: InputMaybe<Boolean_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  shipping_zone_id?: InputMaybe<Bigint_Comparison_Exp>;
  states?: InputMaybe<States_Bool_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "countries" */
export enum Countries_Constraint {
  /** unique or primary key constraint */
  CountriesPkey = 'countries_pkey'
}

/** input type for incrementing numeric columns in table "countries" */
export type Countries_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "countries" */
export type Countries_Insert_Input = {
  abbreviation?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
  states?: InputMaybe<States_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Countries_Max_Fields = {
  __typename?: 'countries_max_fields';
  abbreviation?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "countries" */
export type Countries_Max_Order_By = {
  abbreviation?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Countries_Min_Fields = {
  __typename?: 'countries_min_fields';
  abbreviation?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "countries" */
export type Countries_Min_Order_By = {
  abbreviation?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "countries" */
export type Countries_Mutation_Response = {
  __typename?: 'countries_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Countries>;
};

/** on_conflict condition type for table "countries" */
export type Countries_On_Conflict = {
  constraint: Countries_Constraint;
  update_columns?: Array<Countries_Update_Column>;
  where?: InputMaybe<Countries_Bool_Exp>;
};

/** Ordering options when selecting data from "countries". */
export type Countries_Order_By = {
  abbreviation?: InputMaybe<Order_By>;
  active?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  states_aggregate?: InputMaybe<States_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: countries */
export type Countries_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "countries" */
export enum Countries_Select_Column {
  /** column name */
  Abbreviation = 'abbreviation',
  /** column name */
  Active = 'active',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShippingZoneId = 'shipping_zone_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "countries" */
export type Countries_Set_Input = {
  abbreviation?: InputMaybe<Scalars['String']>;
  active?: InputMaybe<Scalars['Boolean']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Countries_Stddev_Fields = {
  __typename?: 'countries_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "countries" */
export type Countries_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Countries_Stddev_Pop_Fields = {
  __typename?: 'countries_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "countries" */
export type Countries_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Countries_Stddev_Samp_Fields = {
  __typename?: 'countries_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "countries" */
export type Countries_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Countries_Sum_Fields = {
  __typename?: 'countries_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "countries" */
export type Countries_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** update columns of table "countries" */
export enum Countries_Update_Column {
  /** column name */
  Abbreviation = 'abbreviation',
  /** column name */
  Active = 'active',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShippingZoneId = 'shipping_zone_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Countries_Var_Pop_Fields = {
  __typename?: 'countries_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "countries" */
export type Countries_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Countries_Var_Samp_Fields = {
  __typename?: 'countries_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "countries" */
export type Countries_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Countries_Variance_Fields = {
  __typename?: 'countries_variance_fields';
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "countries" */
export type Countries_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "ingredients" */
export type Ingredients = {
  __typename?: 'ingredients';
  created_at: Scalars['timestamp'];
  description?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  quantity?: Maybe<Scalars['numeric']>;
  recipe_id?: Maybe<Scalars['bigint']>;
  unit?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "ingredients" */
export type Ingredients_Aggregate = {
  __typename?: 'ingredients_aggregate';
  aggregate?: Maybe<Ingredients_Aggregate_Fields>;
  nodes: Array<Ingredients>;
};

/** aggregate fields of "ingredients" */
export type Ingredients_Aggregate_Fields = {
  __typename?: 'ingredients_aggregate_fields';
  avg?: Maybe<Ingredients_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Ingredients_Max_Fields>;
  min?: Maybe<Ingredients_Min_Fields>;
  stddev?: Maybe<Ingredients_Stddev_Fields>;
  stddev_pop?: Maybe<Ingredients_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Ingredients_Stddev_Samp_Fields>;
  sum?: Maybe<Ingredients_Sum_Fields>;
  var_pop?: Maybe<Ingredients_Var_Pop_Fields>;
  var_samp?: Maybe<Ingredients_Var_Samp_Fields>;
  variance?: Maybe<Ingredients_Variance_Fields>;
};


/** aggregate fields of "ingredients" */
export type Ingredients_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Ingredients_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "ingredients" */
export type Ingredients_Aggregate_Order_By = {
  avg?: InputMaybe<Ingredients_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Ingredients_Max_Order_By>;
  min?: InputMaybe<Ingredients_Min_Order_By>;
  stddev?: InputMaybe<Ingredients_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Ingredients_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Ingredients_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Ingredients_Sum_Order_By>;
  var_pop?: InputMaybe<Ingredients_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Ingredients_Var_Samp_Order_By>;
  variance?: InputMaybe<Ingredients_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "ingredients" */
export type Ingredients_Arr_Rel_Insert_Input = {
  data: Array<Ingredients_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Ingredients_On_Conflict>;
};

/** aggregate avg on columns */
export type Ingredients_Avg_Fields = {
  __typename?: 'ingredients_avg_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "ingredients" */
export type Ingredients_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "ingredients". All fields are combined with a logical 'AND'. */
export type Ingredients_Bool_Exp = {
  _and?: InputMaybe<Array<Ingredients_Bool_Exp>>;
  _not?: InputMaybe<Ingredients_Bool_Exp>;
  _or?: InputMaybe<Array<Ingredients_Bool_Exp>>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  description?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  quantity?: InputMaybe<Numeric_Comparison_Exp>;
  recipe_id?: InputMaybe<Bigint_Comparison_Exp>;
  unit?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "ingredients" */
export enum Ingredients_Constraint {
  /** unique or primary key constraint */
  IngredientsPkey = 'ingredients_pkey'
}

/** input type for incrementing numeric columns in table "ingredients" */
export type Ingredients_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']>;
  quantity?: InputMaybe<Scalars['numeric']>;
  recipe_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "ingredients" */
export type Ingredients_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamp']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  quantity?: InputMaybe<Scalars['numeric']>;
  recipe_id?: InputMaybe<Scalars['bigint']>;
  unit?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Ingredients_Max_Fields = {
  __typename?: 'ingredients_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['numeric']>;
  recipe_id?: Maybe<Scalars['bigint']>;
  unit?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "ingredients" */
export type Ingredients_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  unit?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Ingredients_Min_Fields = {
  __typename?: 'ingredients_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  description?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['numeric']>;
  recipe_id?: Maybe<Scalars['bigint']>;
  unit?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "ingredients" */
export type Ingredients_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  unit?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "ingredients" */
export type Ingredients_Mutation_Response = {
  __typename?: 'ingredients_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Ingredients>;
};

/** on_conflict condition type for table "ingredients" */
export type Ingredients_On_Conflict = {
  constraint: Ingredients_Constraint;
  update_columns?: Array<Ingredients_Update_Column>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};

/** Ordering options when selecting data from "ingredients". */
export type Ingredients_Order_By = {
  created_at?: InputMaybe<Order_By>;
  description?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  unit?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: ingredients */
export type Ingredients_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "ingredients" */
export enum Ingredients_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RecipeId = 'recipe_id',
  /** column name */
  Unit = 'unit',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "ingredients" */
export type Ingredients_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamp']>;
  description?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  quantity?: InputMaybe<Scalars['numeric']>;
  recipe_id?: InputMaybe<Scalars['bigint']>;
  unit?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Ingredients_Stddev_Fields = {
  __typename?: 'ingredients_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "ingredients" */
export type Ingredients_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Ingredients_Stddev_Pop_Fields = {
  __typename?: 'ingredients_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "ingredients" */
export type Ingredients_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Ingredients_Stddev_Samp_Fields = {
  __typename?: 'ingredients_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "ingredients" */
export type Ingredients_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Ingredients_Sum_Fields = {
  __typename?: 'ingredients_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  quantity?: Maybe<Scalars['numeric']>;
  recipe_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "ingredients" */
export type Ingredients_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** update columns of table "ingredients" */
export enum Ingredients_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Description = 'description',
  /** column name */
  Id = 'id',
  /** column name */
  Quantity = 'quantity',
  /** column name */
  RecipeId = 'recipe_id',
  /** column name */
  Unit = 'unit',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Ingredients_Var_Pop_Fields = {
  __typename?: 'ingredients_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "ingredients" */
export type Ingredients_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Ingredients_Var_Samp_Fields = {
  __typename?: 'ingredients_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "ingredients" */
export type Ingredients_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Ingredients_Variance_Fields = {
  __typename?: 'ingredients_variance_fields';
  id?: Maybe<Scalars['Float']>;
  quantity?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "ingredients" */
export type Ingredients_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  quantity?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
};

/** mutation root */
export type Mutation_Root = {
  __typename?: 'mutation_root';
  addToCart?: Maybe<AddToCartPayload>;
  createAddress?: Maybe<CreateAddressPayload>;
  createOrder?: Maybe<CreateOrderPayload>;
  createProduct?: Maybe<CreateProductPayload>;
  deleteProduct?: Maybe<DeleteProductPayload>;
  deleteShippingZone?: Maybe<DeleteShippingZonePayload>;
  /** delete data from the table: "addresses" */
  delete_addresses?: Maybe<Addresses_Mutation_Response>;
  /** delete single row from the table: "addresses" */
  delete_addresses_by_pk?: Maybe<Addresses>;
  /** delete data from the table: "cart_items" */
  delete_cart_items?: Maybe<Cart_Items_Mutation_Response>;
  /** delete single row from the table: "cart_items" */
  delete_cart_items_by_pk?: Maybe<Cart_Items>;
  /** delete data from the table: "countries" */
  delete_countries?: Maybe<Countries_Mutation_Response>;
  /** delete single row from the table: "countries" */
  delete_countries_by_pk?: Maybe<Countries>;
  /** delete data from the table: "ingredients" */
  delete_ingredients?: Maybe<Ingredients_Mutation_Response>;
  /** delete single row from the table: "ingredients" */
  delete_ingredients_by_pk?: Maybe<Ingredients>;
  /** delete data from the table: "recipe_bookmarks" */
  delete_recipe_bookmarks?: Maybe<Recipe_Bookmarks_Mutation_Response>;
  /** delete single row from the table: "recipe_bookmarks" */
  delete_recipe_bookmarks_by_pk?: Maybe<Recipe_Bookmarks>;
  /** delete data from the table: "recipes" */
  delete_recipes?: Maybe<Recipes_Mutation_Response>;
  /** delete single row from the table: "recipes" */
  delete_recipes_by_pk?: Maybe<Recipes>;
  /** delete data from the table: "shipping_rates" */
  delete_shipping_rates?: Maybe<Shipping_Rates_Mutation_Response>;
  /** delete single row from the table: "shipping_rates" */
  delete_shipping_rates_by_pk?: Maybe<Shipping_Rates>;
  /** delete data from the table: "shipping_zones" */
  delete_shipping_zones?: Maybe<Shipping_Zones_Mutation_Response>;
  /** delete single row from the table: "shipping_zones" */
  delete_shipping_zones_by_pk?: Maybe<Shipping_Zones>;
  /** delete data from the table: "states" */
  delete_states?: Maybe<States_Mutation_Response>;
  /** delete single row from the table: "states" */
  delete_states_by_pk?: Maybe<States>;
  /** delete data from the table: "users" */
  delete_users?: Maybe<Users_Mutation_Response>;
  /** delete single row from the table: "users" */
  delete_users_by_pk?: Maybe<Users>;
  /** insert data into the table: "addresses" */
  insert_addresses?: Maybe<Addresses_Mutation_Response>;
  /** insert a single row into the table: "addresses" */
  insert_addresses_one?: Maybe<Addresses>;
  /** insert data into the table: "cart_items" */
  insert_cart_items?: Maybe<Cart_Items_Mutation_Response>;
  /** insert a single row into the table: "cart_items" */
  insert_cart_items_one?: Maybe<Cart_Items>;
  /** insert data into the table: "countries" */
  insert_countries?: Maybe<Countries_Mutation_Response>;
  /** insert a single row into the table: "countries" */
  insert_countries_one?: Maybe<Countries>;
  /** insert data into the table: "ingredients" */
  insert_ingredients?: Maybe<Ingredients_Mutation_Response>;
  /** insert a single row into the table: "ingredients" */
  insert_ingredients_one?: Maybe<Ingredients>;
  /** insert data into the table: "recipe_bookmarks" */
  insert_recipe_bookmarks?: Maybe<Recipe_Bookmarks_Mutation_Response>;
  /** insert a single row into the table: "recipe_bookmarks" */
  insert_recipe_bookmarks_one?: Maybe<Recipe_Bookmarks>;
  /** insert data into the table: "recipes" */
  insert_recipes?: Maybe<Recipes_Mutation_Response>;
  /** insert a single row into the table: "recipes" */
  insert_recipes_one?: Maybe<Recipes>;
  /** insert data into the table: "shipping_rates" */
  insert_shipping_rates?: Maybe<Shipping_Rates_Mutation_Response>;
  /** insert a single row into the table: "shipping_rates" */
  insert_shipping_rates_one?: Maybe<Shipping_Rates>;
  /** insert data into the table: "shipping_zones" */
  insert_shipping_zones?: Maybe<Shipping_Zones_Mutation_Response>;
  /** insert a single row into the table: "shipping_zones" */
  insert_shipping_zones_one?: Maybe<Shipping_Zones>;
  /** insert data into the table: "states" */
  insert_states?: Maybe<States_Mutation_Response>;
  /** insert a single row into the table: "states" */
  insert_states_one?: Maybe<States>;
  /** insert data into the table: "users" */
  insert_users?: Maybe<Users_Mutation_Response>;
  /** insert a single row into the table: "users" */
  insert_users_one?: Maybe<Users>;
  settingShippingZone?: Maybe<SettingShippingZonePayload>;
  updateCartQty?: Maybe<UpdateCartQtyPayload>;
  updateProduct?: Maybe<UpdateProductPayload>;
  /** update data of the table: "addresses" */
  update_addresses?: Maybe<Addresses_Mutation_Response>;
  /** update single row of the table: "addresses" */
  update_addresses_by_pk?: Maybe<Addresses>;
  /** update data of the table: "cart_items" */
  update_cart_items?: Maybe<Cart_Items_Mutation_Response>;
  /** update single row of the table: "cart_items" */
  update_cart_items_by_pk?: Maybe<Cart_Items>;
  /** update data of the table: "countries" */
  update_countries?: Maybe<Countries_Mutation_Response>;
  /** update single row of the table: "countries" */
  update_countries_by_pk?: Maybe<Countries>;
  /** update data of the table: "ingredients" */
  update_ingredients?: Maybe<Ingredients_Mutation_Response>;
  /** update single row of the table: "ingredients" */
  update_ingredients_by_pk?: Maybe<Ingredients>;
  /** update data of the table: "recipe_bookmarks" */
  update_recipe_bookmarks?: Maybe<Recipe_Bookmarks_Mutation_Response>;
  /** update single row of the table: "recipe_bookmarks" */
  update_recipe_bookmarks_by_pk?: Maybe<Recipe_Bookmarks>;
  /** update data of the table: "recipes" */
  update_recipes?: Maybe<Recipes_Mutation_Response>;
  /** update single row of the table: "recipes" */
  update_recipes_by_pk?: Maybe<Recipes>;
  /** update data of the table: "shipping_rates" */
  update_shipping_rates?: Maybe<Shipping_Rates_Mutation_Response>;
  /** update single row of the table: "shipping_rates" */
  update_shipping_rates_by_pk?: Maybe<Shipping_Rates>;
  /** update data of the table: "shipping_zones" */
  update_shipping_zones?: Maybe<Shipping_Zones_Mutation_Response>;
  /** update single row of the table: "shipping_zones" */
  update_shipping_zones_by_pk?: Maybe<Shipping_Zones>;
  /** update data of the table: "states" */
  update_states?: Maybe<States_Mutation_Response>;
  /** update single row of the table: "states" */
  update_states_by_pk?: Maybe<States>;
  /** update data of the table: "users" */
  update_users?: Maybe<Users_Mutation_Response>;
  /** update single row of the table: "users" */
  update_users_by_pk?: Maybe<Users>;
};


/** mutation root */
export type Mutation_RootAddToCartArgs = {
  input: AddToCartInput;
};


/** mutation root */
export type Mutation_RootCreateAddressArgs = {
  input: CreateAddressInput;
};


/** mutation root */
export type Mutation_RootCreateOrderArgs = {
  input: CreateOrderInput;
};


/** mutation root */
export type Mutation_RootCreateProductArgs = {
  input: CreateProductInput;
};


/** mutation root */
export type Mutation_RootDeleteProductArgs = {
  input: DeleteProductInput;
};


/** mutation root */
export type Mutation_RootDeleteShippingZoneArgs = {
  input: DeleteShippingZoneInput;
};


/** mutation root */
export type Mutation_RootDelete_AddressesArgs = {
  where: Addresses_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Addresses_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Cart_ItemsArgs = {
  where: Cart_Items_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Cart_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_CountriesArgs = {
  where: Countries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Countries_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_IngredientsArgs = {
  where: Ingredients_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Ingredients_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Recipe_BookmarksArgs = {
  where: Recipe_Bookmarks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Recipe_Bookmarks_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_RecipesArgs = {
  where: Recipes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Recipes_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_RatesArgs = {
  where: Shipping_Rates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Rates_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_Shipping_ZonesArgs = {
  where: Shipping_Zones_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Shipping_Zones_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_StatesArgs = {
  where: States_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_States_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootDelete_UsersArgs = {
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootDelete_Users_By_PkArgs = {
  id: Scalars['bigint'];
};


/** mutation root */
export type Mutation_RootInsert_AddressesArgs = {
  objects: Array<Addresses_Insert_Input>;
  on_conflict?: InputMaybe<Addresses_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Addresses_OneArgs = {
  object: Addresses_Insert_Input;
  on_conflict?: InputMaybe<Addresses_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cart_ItemsArgs = {
  objects: Array<Cart_Items_Insert_Input>;
  on_conflict?: InputMaybe<Cart_Items_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Cart_Items_OneArgs = {
  object: Cart_Items_Insert_Input;
  on_conflict?: InputMaybe<Cart_Items_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_CountriesArgs = {
  objects: Array<Countries_Insert_Input>;
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Countries_OneArgs = {
  object: Countries_Insert_Input;
  on_conflict?: InputMaybe<Countries_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_IngredientsArgs = {
  objects: Array<Ingredients_Insert_Input>;
  on_conflict?: InputMaybe<Ingredients_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Ingredients_OneArgs = {
  object: Ingredients_Insert_Input;
  on_conflict?: InputMaybe<Ingredients_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Recipe_BookmarksArgs = {
  objects: Array<Recipe_Bookmarks_Insert_Input>;
  on_conflict?: InputMaybe<Recipe_Bookmarks_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Recipe_Bookmarks_OneArgs = {
  object: Recipe_Bookmarks_Insert_Input;
  on_conflict?: InputMaybe<Recipe_Bookmarks_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_RecipesArgs = {
  objects: Array<Recipes_Insert_Input>;
  on_conflict?: InputMaybe<Recipes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Recipes_OneArgs = {
  object: Recipes_Insert_Input;
  on_conflict?: InputMaybe<Recipes_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_RatesArgs = {
  objects: Array<Shipping_Rates_Insert_Input>;
  on_conflict?: InputMaybe<Shipping_Rates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Rates_OneArgs = {
  object: Shipping_Rates_Insert_Input;
  on_conflict?: InputMaybe<Shipping_Rates_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_ZonesArgs = {
  objects: Array<Shipping_Zones_Insert_Input>;
  on_conflict?: InputMaybe<Shipping_Zones_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Shipping_Zones_OneArgs = {
  object: Shipping_Zones_Insert_Input;
  on_conflict?: InputMaybe<Shipping_Zones_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_StatesArgs = {
  objects: Array<States_Insert_Input>;
  on_conflict?: InputMaybe<States_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_States_OneArgs = {
  object: States_Insert_Input;
  on_conflict?: InputMaybe<States_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_UsersArgs = {
  objects: Array<Users_Insert_Input>;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootInsert_Users_OneArgs = {
  object: Users_Insert_Input;
  on_conflict?: InputMaybe<Users_On_Conflict>;
};


/** mutation root */
export type Mutation_RootSettingShippingZoneArgs = {
  input: SettingShippingZoneInput;
};


/** mutation root */
export type Mutation_RootUpdateCartQtyArgs = {
  input: UpdateCartQtyInput;
};


/** mutation root */
export type Mutation_RootUpdateProductArgs = {
  input: UpdateProductInput;
};


/** mutation root */
export type Mutation_RootUpdate_AddressesArgs = {
  _inc?: InputMaybe<Addresses_Inc_Input>;
  _set?: InputMaybe<Addresses_Set_Input>;
  where: Addresses_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Addresses_By_PkArgs = {
  _inc?: InputMaybe<Addresses_Inc_Input>;
  _set?: InputMaybe<Addresses_Set_Input>;
  pk_columns: Addresses_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Cart_ItemsArgs = {
  _inc?: InputMaybe<Cart_Items_Inc_Input>;
  _set?: InputMaybe<Cart_Items_Set_Input>;
  where: Cart_Items_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Cart_Items_By_PkArgs = {
  _inc?: InputMaybe<Cart_Items_Inc_Input>;
  _set?: InputMaybe<Cart_Items_Set_Input>;
  pk_columns: Cart_Items_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_CountriesArgs = {
  _inc?: InputMaybe<Countries_Inc_Input>;
  _set?: InputMaybe<Countries_Set_Input>;
  where: Countries_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Countries_By_PkArgs = {
  _inc?: InputMaybe<Countries_Inc_Input>;
  _set?: InputMaybe<Countries_Set_Input>;
  pk_columns: Countries_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_IngredientsArgs = {
  _inc?: InputMaybe<Ingredients_Inc_Input>;
  _set?: InputMaybe<Ingredients_Set_Input>;
  where: Ingredients_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Ingredients_By_PkArgs = {
  _inc?: InputMaybe<Ingredients_Inc_Input>;
  _set?: InputMaybe<Ingredients_Set_Input>;
  pk_columns: Ingredients_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Recipe_BookmarksArgs = {
  _inc?: InputMaybe<Recipe_Bookmarks_Inc_Input>;
  _set?: InputMaybe<Recipe_Bookmarks_Set_Input>;
  where: Recipe_Bookmarks_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Recipe_Bookmarks_By_PkArgs = {
  _inc?: InputMaybe<Recipe_Bookmarks_Inc_Input>;
  _set?: InputMaybe<Recipe_Bookmarks_Set_Input>;
  pk_columns: Recipe_Bookmarks_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_RecipesArgs = {
  _inc?: InputMaybe<Recipes_Inc_Input>;
  _set?: InputMaybe<Recipes_Set_Input>;
  where: Recipes_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Recipes_By_PkArgs = {
  _inc?: InputMaybe<Recipes_Inc_Input>;
  _set?: InputMaybe<Recipes_Set_Input>;
  pk_columns: Recipes_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_RatesArgs = {
  _inc?: InputMaybe<Shipping_Rates_Inc_Input>;
  _set?: InputMaybe<Shipping_Rates_Set_Input>;
  where: Shipping_Rates_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Rates_By_PkArgs = {
  _inc?: InputMaybe<Shipping_Rates_Inc_Input>;
  _set?: InputMaybe<Shipping_Rates_Set_Input>;
  pk_columns: Shipping_Rates_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_ZonesArgs = {
  _inc?: InputMaybe<Shipping_Zones_Inc_Input>;
  _set?: InputMaybe<Shipping_Zones_Set_Input>;
  where: Shipping_Zones_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Shipping_Zones_By_PkArgs = {
  _inc?: InputMaybe<Shipping_Zones_Inc_Input>;
  _set?: InputMaybe<Shipping_Zones_Set_Input>;
  pk_columns: Shipping_Zones_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_StatesArgs = {
  _inc?: InputMaybe<States_Inc_Input>;
  _set?: InputMaybe<States_Set_Input>;
  where: States_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_States_By_PkArgs = {
  _inc?: InputMaybe<States_Inc_Input>;
  _set?: InputMaybe<States_Set_Input>;
  pk_columns: States_Pk_Columns_Input;
};


/** mutation root */
export type Mutation_RootUpdate_UsersArgs = {
  _inc?: InputMaybe<Users_Inc_Input>;
  _set?: InputMaybe<Users_Set_Input>;
  where: Users_Bool_Exp;
};


/** mutation root */
export type Mutation_RootUpdate_Users_By_PkArgs = {
  _inc?: InputMaybe<Users_Inc_Input>;
  _set?: InputMaybe<Users_Set_Input>;
  pk_columns: Users_Pk_Columns_Input;
};

/** Boolean expression to compare columns of type "numeric". All fields are combined with logical 'AND'. */
export type Numeric_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['numeric']>;
  _gt?: InputMaybe<Scalars['numeric']>;
  _gte?: InputMaybe<Scalars['numeric']>;
  _in?: InputMaybe<Array<Scalars['numeric']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['numeric']>;
  _lte?: InputMaybe<Scalars['numeric']>;
  _neq?: InputMaybe<Scalars['numeric']>;
  _nin?: InputMaybe<Array<Scalars['numeric']>>;
};

/** column ordering options */
export enum Order_By {
  /** in ascending order, nulls last */
  Asc = 'asc',
  /** in ascending order, nulls first */
  AscNullsFirst = 'asc_nulls_first',
  /** in ascending order, nulls last */
  AscNullsLast = 'asc_nulls_last',
  /** in descending order, nulls first */
  Desc = 'desc',
  /** in descending order, nulls first */
  DescNullsFirst = 'desc_nulls_first',
  /** in descending order, nulls last */
  DescNullsLast = 'desc_nulls_last'
}

export type Query_Root = {
  __typename?: 'query_root';
  /** fetch data from the table: "addresses" */
  addresses: Array<Addresses>;
  /** fetch aggregated fields from the table: "addresses" */
  addresses_aggregate: Addresses_Aggregate;
  /** fetch data from the table: "addresses" using primary key columns */
  addresses_by_pk?: Maybe<Addresses>;
  cart?: Maybe<Cart>;
  /** fetch data from the table: "cart_items" */
  cart_items: Array<Cart_Items>;
  /** fetch aggregated fields from the table: "cart_items" */
  cart_items_aggregate: Cart_Items_Aggregate;
  /** fetch data from the table: "cart_items" using primary key columns */
  cart_items_by_pk?: Maybe<Cart_Items>;
  /** An array relationship */
  countries: Array<Countries>;
  /** An aggregate relationship */
  countries_aggregate: Countries_Aggregate;
  /** fetch data from the table: "countries" using primary key columns */
  countries_by_pk?: Maybe<Countries>;
  /** An array relationship */
  ingredients: Array<Ingredients>;
  /** An aggregate relationship */
  ingredients_aggregate: Ingredients_Aggregate;
  /** fetch data from the table: "ingredients" using primary key columns */
  ingredients_by_pk?: Maybe<Ingredients>;
  product?: Maybe<Product>;
  products?: Maybe<Array<Product>>;
  /** An array relationship */
  recipe_bookmarks: Array<Recipe_Bookmarks>;
  /** An aggregate relationship */
  recipe_bookmarks_aggregate: Recipe_Bookmarks_Aggregate;
  /** fetch data from the table: "recipe_bookmarks" using primary key columns */
  recipe_bookmarks_by_pk?: Maybe<Recipe_Bookmarks>;
  /** fetch data from the table: "recipes" */
  recipes: Array<Recipes>;
  /** fetch aggregated fields from the table: "recipes" */
  recipes_aggregate: Recipes_Aggregate;
  /** fetch data from the table: "recipes" using primary key columns */
  recipes_by_pk?: Maybe<Recipes>;
  shippingOptions: Array<ShippingOption>;
  /** fetch data from the table: "shipping_rates" */
  shipping_rates: Array<Shipping_Rates>;
  /** fetch aggregated fields from the table: "shipping_rates" */
  shipping_rates_aggregate: Shipping_Rates_Aggregate;
  /** fetch data from the table: "shipping_rates" using primary key columns */
  shipping_rates_by_pk?: Maybe<Shipping_Rates>;
  /** fetch data from the table: "shipping_zones" */
  shipping_zones: Array<Shipping_Zones>;
  /** fetch aggregated fields from the table: "shipping_zones" */
  shipping_zones_aggregate: Shipping_Zones_Aggregate;
  /** fetch data from the table: "shipping_zones" using primary key columns */
  shipping_zones_by_pk?: Maybe<Shipping_Zones>;
  /** An array relationship */
  states: Array<States>;
  /** An aggregate relationship */
  states_aggregate: States_Aggregate;
  /** fetch data from the table: "states" using primary key columns */
  states_by_pk?: Maybe<States>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
};


export type Query_RootAddressesArgs = {
  distinct_on?: InputMaybe<Array<Addresses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Addresses_Order_By>>;
  where?: InputMaybe<Addresses_Bool_Exp>;
};


export type Query_RootAddresses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Addresses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Addresses_Order_By>>;
  where?: InputMaybe<Addresses_Bool_Exp>;
};


export type Query_RootAddresses_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootCartArgs = {
  userId: Scalars['Int'];
};


export type Query_RootCart_ItemsArgs = {
  distinct_on?: InputMaybe<Array<Cart_Items_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Cart_Items_Order_By>>;
  where?: InputMaybe<Cart_Items_Bool_Exp>;
};


export type Query_RootCart_Items_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cart_Items_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Cart_Items_Order_By>>;
  where?: InputMaybe<Cart_Items_Bool_Exp>;
};


export type Query_RootCart_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootCountriesArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Query_RootCountries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Query_RootCountries_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootIngredientsArgs = {
  distinct_on?: InputMaybe<Array<Ingredients_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Ingredients_Order_By>>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};


export type Query_RootIngredients_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ingredients_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Ingredients_Order_By>>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};


export type Query_RootIngredients_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootProductArgs = {
  id: Scalars['ID'];
};


export type Query_RootRecipe_BookmarksArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};


export type Query_RootRecipe_Bookmarks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};


export type Query_RootRecipe_Bookmarks_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootRecipesArgs = {
  distinct_on?: InputMaybe<Array<Recipes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipes_Order_By>>;
  where?: InputMaybe<Recipes_Bool_Exp>;
};


export type Query_RootRecipes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Recipes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipes_Order_By>>;
  where?: InputMaybe<Recipes_Bool_Exp>;
};


export type Query_RootRecipes_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootShippingOptionsArgs = {
  cartId: Scalars['Int'];
  countryId: Scalars['Int'];
  stateId?: InputMaybe<Scalars['Int']>;
};


export type Query_RootShipping_RatesArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Rates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Rates_Order_By>>;
  where?: InputMaybe<Shipping_Rates_Bool_Exp>;
};


export type Query_RootShipping_Rates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Rates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Rates_Order_By>>;
  where?: InputMaybe<Shipping_Rates_Bool_Exp>;
};


export type Query_RootShipping_Rates_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootShipping_ZonesArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Zones_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Zones_Order_By>>;
  where?: InputMaybe<Shipping_Zones_Bool_Exp>;
};


export type Query_RootShipping_Zones_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Zones_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Zones_Order_By>>;
  where?: InputMaybe<Shipping_Zones_Bool_Exp>;
};


export type Query_RootShipping_Zones_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootStatesArgs = {
  distinct_on?: InputMaybe<Array<States_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<States_Order_By>>;
  where?: InputMaybe<States_Bool_Exp>;
};


export type Query_RootStates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<States_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<States_Order_By>>;
  where?: InputMaybe<States_Bool_Exp>;
};


export type Query_RootStates_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Query_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Query_RootUsers_By_PkArgs = {
  id: Scalars['bigint'];
};

/** columns and relationships of "recipe_bookmarks" */
export type Recipe_Bookmarks = {
  __typename?: 'recipe_bookmarks';
  created_at: Scalars['timestamp'];
  id: Scalars['bigint'];
  /** An object relationship */
  recipe?: Maybe<Recipes>;
  recipe_id?: Maybe<Scalars['bigint']>;
  updated_at: Scalars['timestamp'];
  /** An object relationship */
  user?: Maybe<Users>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** aggregated selection of "recipe_bookmarks" */
export type Recipe_Bookmarks_Aggregate = {
  __typename?: 'recipe_bookmarks_aggregate';
  aggregate?: Maybe<Recipe_Bookmarks_Aggregate_Fields>;
  nodes: Array<Recipe_Bookmarks>;
};

/** aggregate fields of "recipe_bookmarks" */
export type Recipe_Bookmarks_Aggregate_Fields = {
  __typename?: 'recipe_bookmarks_aggregate_fields';
  avg?: Maybe<Recipe_Bookmarks_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Recipe_Bookmarks_Max_Fields>;
  min?: Maybe<Recipe_Bookmarks_Min_Fields>;
  stddev?: Maybe<Recipe_Bookmarks_Stddev_Fields>;
  stddev_pop?: Maybe<Recipe_Bookmarks_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Recipe_Bookmarks_Stddev_Samp_Fields>;
  sum?: Maybe<Recipe_Bookmarks_Sum_Fields>;
  var_pop?: Maybe<Recipe_Bookmarks_Var_Pop_Fields>;
  var_samp?: Maybe<Recipe_Bookmarks_Var_Samp_Fields>;
  variance?: Maybe<Recipe_Bookmarks_Variance_Fields>;
};


/** aggregate fields of "recipe_bookmarks" */
export type Recipe_Bookmarks_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Aggregate_Order_By = {
  avg?: InputMaybe<Recipe_Bookmarks_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<Recipe_Bookmarks_Max_Order_By>;
  min?: InputMaybe<Recipe_Bookmarks_Min_Order_By>;
  stddev?: InputMaybe<Recipe_Bookmarks_Stddev_Order_By>;
  stddev_pop?: InputMaybe<Recipe_Bookmarks_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<Recipe_Bookmarks_Stddev_Samp_Order_By>;
  sum?: InputMaybe<Recipe_Bookmarks_Sum_Order_By>;
  var_pop?: InputMaybe<Recipe_Bookmarks_Var_Pop_Order_By>;
  var_samp?: InputMaybe<Recipe_Bookmarks_Var_Samp_Order_By>;
  variance?: InputMaybe<Recipe_Bookmarks_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "recipe_bookmarks" */
export type Recipe_Bookmarks_Arr_Rel_Insert_Input = {
  data: Array<Recipe_Bookmarks_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<Recipe_Bookmarks_On_Conflict>;
};

/** aggregate avg on columns */
export type Recipe_Bookmarks_Avg_Fields = {
  __typename?: 'recipe_bookmarks_avg_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Avg_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "recipe_bookmarks". All fields are combined with a logical 'AND'. */
export type Recipe_Bookmarks_Bool_Exp = {
  _and?: InputMaybe<Array<Recipe_Bookmarks_Bool_Exp>>;
  _not?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
  _or?: InputMaybe<Array<Recipe_Bookmarks_Bool_Exp>>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  recipe?: InputMaybe<Recipes_Bool_Exp>;
  recipe_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  user?: InputMaybe<Users_Bool_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "recipe_bookmarks" */
export enum Recipe_Bookmarks_Constraint {
  /** unique or primary key constraint */
  RecipeBookmarksPkey = 'recipe_bookmarks_pkey'
}

/** input type for incrementing numeric columns in table "recipe_bookmarks" */
export type Recipe_Bookmarks_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']>;
  recipe_id?: InputMaybe<Scalars['bigint']>;
  user_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "recipe_bookmarks" */
export type Recipe_Bookmarks_Insert_Input = {
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  recipe?: InputMaybe<Recipes_Obj_Rel_Insert_Input>;
  recipe_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  user?: InputMaybe<Users_Obj_Rel_Insert_Input>;
  user_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Recipe_Bookmarks_Max_Fields = {
  __typename?: 'recipe_bookmarks_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  recipe_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** order by max() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Max_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type Recipe_Bookmarks_Min_Fields = {
  __typename?: 'recipe_bookmarks_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  recipe_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** order by min() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Min_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "recipe_bookmarks" */
export type Recipe_Bookmarks_Mutation_Response = {
  __typename?: 'recipe_bookmarks_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Recipe_Bookmarks>;
};

/** on_conflict condition type for table "recipe_bookmarks" */
export type Recipe_Bookmarks_On_Conflict = {
  constraint: Recipe_Bookmarks_Constraint;
  update_columns?: Array<Recipe_Bookmarks_Update_Column>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};

/** Ordering options when selecting data from "recipe_bookmarks". */
export type Recipe_Bookmarks_Order_By = {
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  recipe?: InputMaybe<Recipes_Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user?: InputMaybe<Users_Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: recipe_bookmarks */
export type Recipe_Bookmarks_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "recipe_bookmarks" */
export enum Recipe_Bookmarks_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  RecipeId = 'recipe_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "recipe_bookmarks" */
export type Recipe_Bookmarks_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  recipe_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  user_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Recipe_Bookmarks_Stddev_Fields = {
  __typename?: 'recipe_bookmarks_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Stddev_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type Recipe_Bookmarks_Stddev_Pop_Fields = {
  __typename?: 'recipe_bookmarks_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Stddev_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type Recipe_Bookmarks_Stddev_Samp_Fields = {
  __typename?: 'recipe_bookmarks_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Stddev_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type Recipe_Bookmarks_Sum_Fields = {
  __typename?: 'recipe_bookmarks_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  recipe_id?: Maybe<Scalars['bigint']>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Sum_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** update columns of table "recipe_bookmarks" */
export enum Recipe_Bookmarks_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  RecipeId = 'recipe_id',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** aggregate var_pop on columns */
export type Recipe_Bookmarks_Var_Pop_Fields = {
  __typename?: 'recipe_bookmarks_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Var_Pop_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type Recipe_Bookmarks_Var_Samp_Fields = {
  __typename?: 'recipe_bookmarks_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Var_Samp_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type Recipe_Bookmarks_Variance_Fields = {
  __typename?: 'recipe_bookmarks_variance_fields';
  id?: Maybe<Scalars['Float']>;
  recipe_id?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "recipe_bookmarks" */
export type Recipe_Bookmarks_Variance_Order_By = {
  id?: InputMaybe<Order_By>;
  recipe_id?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** columns and relationships of "recipes" */
export type Recipes = {
  __typename?: 'recipes';
  cooking_time?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamp'];
  id: Scalars['bigint'];
  image_url?: Maybe<Scalars['String']>;
  /** An array relationship */
  ingredients: Array<Ingredients>;
  /** An aggregate relationship */
  ingredients_aggregate: Ingredients_Aggregate;
  publisher?: Maybe<Scalars['String']>;
  /** An array relationship */
  recipe_bookmarks: Array<Recipe_Bookmarks>;
  /** An aggregate relationship */
  recipe_bookmarks_aggregate: Recipe_Bookmarks_Aggregate;
  servings?: Maybe<Scalars['Int']>;
  source_url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updated_at: Scalars['timestamp'];
  user_id?: Maybe<Scalars['bigint']>;
};


/** columns and relationships of "recipes" */
export type RecipesIngredientsArgs = {
  distinct_on?: InputMaybe<Array<Ingredients_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Ingredients_Order_By>>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};


/** columns and relationships of "recipes" */
export type RecipesIngredients_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ingredients_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Ingredients_Order_By>>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};


/** columns and relationships of "recipes" */
export type RecipesRecipe_BookmarksArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};


/** columns and relationships of "recipes" */
export type RecipesRecipe_Bookmarks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};

/** aggregated selection of "recipes" */
export type Recipes_Aggregate = {
  __typename?: 'recipes_aggregate';
  aggregate?: Maybe<Recipes_Aggregate_Fields>;
  nodes: Array<Recipes>;
};

/** aggregate fields of "recipes" */
export type Recipes_Aggregate_Fields = {
  __typename?: 'recipes_aggregate_fields';
  avg?: Maybe<Recipes_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Recipes_Max_Fields>;
  min?: Maybe<Recipes_Min_Fields>;
  stddev?: Maybe<Recipes_Stddev_Fields>;
  stddev_pop?: Maybe<Recipes_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Recipes_Stddev_Samp_Fields>;
  sum?: Maybe<Recipes_Sum_Fields>;
  var_pop?: Maybe<Recipes_Var_Pop_Fields>;
  var_samp?: Maybe<Recipes_Var_Samp_Fields>;
  variance?: Maybe<Recipes_Variance_Fields>;
};


/** aggregate fields of "recipes" */
export type Recipes_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Recipes_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Recipes_Avg_Fields = {
  __typename?: 'recipes_avg_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "recipes". All fields are combined with a logical 'AND'. */
export type Recipes_Bool_Exp = {
  _and?: InputMaybe<Array<Recipes_Bool_Exp>>;
  _not?: InputMaybe<Recipes_Bool_Exp>;
  _or?: InputMaybe<Array<Recipes_Bool_Exp>>;
  cooking_time?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  image_url?: InputMaybe<String_Comparison_Exp>;
  ingredients?: InputMaybe<Ingredients_Bool_Exp>;
  publisher?: InputMaybe<String_Comparison_Exp>;
  recipe_bookmarks?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
  servings?: InputMaybe<Int_Comparison_Exp>;
  source_url?: InputMaybe<String_Comparison_Exp>;
  title?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
  user_id?: InputMaybe<Bigint_Comparison_Exp>;
};

/** unique or primary key constraints on table "recipes" */
export enum Recipes_Constraint {
  /** unique or primary key constraint */
  RecipesPkey = 'recipes_pkey'
}

/** input type for incrementing numeric columns in table "recipes" */
export type Recipes_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']>;
  servings?: InputMaybe<Scalars['Int']>;
  user_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "recipes" */
export type Recipes_Insert_Input = {
  cooking_time?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  image_url?: InputMaybe<Scalars['String']>;
  ingredients?: InputMaybe<Ingredients_Arr_Rel_Insert_Input>;
  publisher?: InputMaybe<Scalars['String']>;
  recipe_bookmarks?: InputMaybe<Recipe_Bookmarks_Arr_Rel_Insert_Input>;
  servings?: InputMaybe<Scalars['Int']>;
  source_url?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  user_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate max on columns */
export type Recipes_Max_Fields = {
  __typename?: 'recipes_max_fields';
  cooking_time?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  publisher?: Maybe<Scalars['String']>;
  servings?: Maybe<Scalars['Int']>;
  source_url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** aggregate min on columns */
export type Recipes_Min_Fields = {
  __typename?: 'recipes_min_fields';
  cooking_time?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  image_url?: Maybe<Scalars['String']>;
  publisher?: Maybe<Scalars['String']>;
  servings?: Maybe<Scalars['Int']>;
  source_url?: Maybe<Scalars['String']>;
  title?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** response of any mutation on the table "recipes" */
export type Recipes_Mutation_Response = {
  __typename?: 'recipes_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Recipes>;
};

/** input type for inserting object relation for remote table "recipes" */
export type Recipes_Obj_Rel_Insert_Input = {
  data: Recipes_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Recipes_On_Conflict>;
};

/** on_conflict condition type for table "recipes" */
export type Recipes_On_Conflict = {
  constraint: Recipes_Constraint;
  update_columns?: Array<Recipes_Update_Column>;
  where?: InputMaybe<Recipes_Bool_Exp>;
};

/** Ordering options when selecting data from "recipes". */
export type Recipes_Order_By = {
  cooking_time?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  image_url?: InputMaybe<Order_By>;
  ingredients_aggregate?: InputMaybe<Ingredients_Aggregate_Order_By>;
  publisher?: InputMaybe<Order_By>;
  recipe_bookmarks_aggregate?: InputMaybe<Recipe_Bookmarks_Aggregate_Order_By>;
  servings?: InputMaybe<Order_By>;
  source_url?: InputMaybe<Order_By>;
  title?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
  user_id?: InputMaybe<Order_By>;
};

/** primary key columns input for table: recipes */
export type Recipes_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "recipes" */
export enum Recipes_Select_Column {
  /** column name */
  CookingTime = 'cooking_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Publisher = 'publisher',
  /** column name */
  Servings = 'servings',
  /** column name */
  SourceUrl = 'source_url',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** input type for updating data in table "recipes" */
export type Recipes_Set_Input = {
  cooking_time?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  image_url?: InputMaybe<Scalars['String']>;
  publisher?: InputMaybe<Scalars['String']>;
  servings?: InputMaybe<Scalars['Int']>;
  source_url?: InputMaybe<Scalars['String']>;
  title?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
  user_id?: InputMaybe<Scalars['bigint']>;
};

/** aggregate stddev on columns */
export type Recipes_Stddev_Fields = {
  __typename?: 'recipes_stddev_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Recipes_Stddev_Pop_Fields = {
  __typename?: 'recipes_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Recipes_Stddev_Samp_Fields = {
  __typename?: 'recipes_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Recipes_Sum_Fields = {
  __typename?: 'recipes_sum_fields';
  id?: Maybe<Scalars['bigint']>;
  servings?: Maybe<Scalars['Int']>;
  user_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "recipes" */
export enum Recipes_Update_Column {
  /** column name */
  CookingTime = 'cooking_time',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  ImageUrl = 'image_url',
  /** column name */
  Publisher = 'publisher',
  /** column name */
  Servings = 'servings',
  /** column name */
  SourceUrl = 'source_url',
  /** column name */
  Title = 'title',
  /** column name */
  UpdatedAt = 'updated_at',
  /** column name */
  UserId = 'user_id'
}

/** aggregate var_pop on columns */
export type Recipes_Var_Pop_Fields = {
  __typename?: 'recipes_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Recipes_Var_Samp_Fields = {
  __typename?: 'recipes_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Recipes_Variance_Fields = {
  __typename?: 'recipes_variance_fields';
  id?: Maybe<Scalars['Float']>;
  servings?: Maybe<Scalars['Float']>;
  user_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "shipping_rates" */
export type Shipping_Rates = {
  __typename?: 'shipping_rates';
  amount: Scalars['numeric'];
  created_at: Scalars['timestamp'];
  id: Scalars['bigint'];
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "shipping_rates" */
export type Shipping_Rates_Aggregate = {
  __typename?: 'shipping_rates_aggregate';
  aggregate?: Maybe<Shipping_Rates_Aggregate_Fields>;
  nodes: Array<Shipping_Rates>;
};

/** aggregate fields of "shipping_rates" */
export type Shipping_Rates_Aggregate_Fields = {
  __typename?: 'shipping_rates_aggregate_fields';
  avg?: Maybe<Shipping_Rates_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Shipping_Rates_Max_Fields>;
  min?: Maybe<Shipping_Rates_Min_Fields>;
  stddev?: Maybe<Shipping_Rates_Stddev_Fields>;
  stddev_pop?: Maybe<Shipping_Rates_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Shipping_Rates_Stddev_Samp_Fields>;
  sum?: Maybe<Shipping_Rates_Sum_Fields>;
  var_pop?: Maybe<Shipping_Rates_Var_Pop_Fields>;
  var_samp?: Maybe<Shipping_Rates_Var_Samp_Fields>;
  variance?: Maybe<Shipping_Rates_Variance_Fields>;
};


/** aggregate fields of "shipping_rates" */
export type Shipping_Rates_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Shipping_Rates_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Shipping_Rates_Avg_Fields = {
  __typename?: 'shipping_rates_avg_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "shipping_rates". All fields are combined with a logical 'AND'. */
export type Shipping_Rates_Bool_Exp = {
  _and?: InputMaybe<Array<Shipping_Rates_Bool_Exp>>;
  _not?: InputMaybe<Shipping_Rates_Bool_Exp>;
  _or?: InputMaybe<Array<Shipping_Rates_Bool_Exp>>;
  amount?: InputMaybe<Numeric_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  shipping_zone_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_rates" */
export enum Shipping_Rates_Constraint {
  /** unique or primary key constraint */
  ShippingRatesPkey = 'shipping_rates_pkey'
}

/** input type for incrementing numeric columns in table "shipping_rates" */
export type Shipping_Rates_Inc_Input = {
  amount?: InputMaybe<Scalars['numeric']>;
  id?: InputMaybe<Scalars['bigint']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "shipping_rates" */
export type Shipping_Rates_Insert_Input = {
  amount?: InputMaybe<Scalars['numeric']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Shipping_Rates_Max_Fields = {
  __typename?: 'shipping_rates_max_fields';
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Shipping_Rates_Min_Fields = {
  __typename?: 'shipping_rates_min_fields';
  amount?: Maybe<Scalars['numeric']>;
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "shipping_rates" */
export type Shipping_Rates_Mutation_Response = {
  __typename?: 'shipping_rates_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Rates>;
};

/** on_conflict condition type for table "shipping_rates" */
export type Shipping_Rates_On_Conflict = {
  constraint: Shipping_Rates_Constraint;
  update_columns?: Array<Shipping_Rates_Update_Column>;
  where?: InputMaybe<Shipping_Rates_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_rates". */
export type Shipping_Rates_Order_By = {
  amount?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: shipping_rates */
export type Shipping_Rates_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "shipping_rates" */
export enum Shipping_Rates_Select_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShippingZoneId = 'shipping_zone_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "shipping_rates" */
export type Shipping_Rates_Set_Input = {
  amount?: InputMaybe<Scalars['numeric']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Shipping_Rates_Stddev_Fields = {
  __typename?: 'shipping_rates_stddev_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Shipping_Rates_Stddev_Pop_Fields = {
  __typename?: 'shipping_rates_stddev_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Shipping_Rates_Stddev_Samp_Fields = {
  __typename?: 'shipping_rates_stddev_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Shipping_Rates_Sum_Fields = {
  __typename?: 'shipping_rates_sum_fields';
  amount?: Maybe<Scalars['numeric']>;
  id?: Maybe<Scalars['bigint']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "shipping_rates" */
export enum Shipping_Rates_Update_Column {
  /** column name */
  Amount = 'amount',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShippingZoneId = 'shipping_zone_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Shipping_Rates_Var_Pop_Fields = {
  __typename?: 'shipping_rates_var_pop_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Shipping_Rates_Var_Samp_Fields = {
  __typename?: 'shipping_rates_var_samp_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Shipping_Rates_Variance_Fields = {
  __typename?: 'shipping_rates_variance_fields';
  amount?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "shipping_zones" */
export type Shipping_Zones = {
  __typename?: 'shipping_zones';
  /** An array relationship */
  countries: Array<Countries>;
  /** An aggregate relationship */
  countries_aggregate: Countries_Aggregate;
  created_at: Scalars['timestamp'];
  id: Scalars['bigint'];
  name: Scalars['String'];
  updated_at: Scalars['timestamp'];
};


/** columns and relationships of "shipping_zones" */
export type Shipping_ZonesCountriesArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


/** columns and relationships of "shipping_zones" */
export type Shipping_ZonesCountries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};

/** aggregated selection of "shipping_zones" */
export type Shipping_Zones_Aggregate = {
  __typename?: 'shipping_zones_aggregate';
  aggregate?: Maybe<Shipping_Zones_Aggregate_Fields>;
  nodes: Array<Shipping_Zones>;
};

/** aggregate fields of "shipping_zones" */
export type Shipping_Zones_Aggregate_Fields = {
  __typename?: 'shipping_zones_aggregate_fields';
  avg?: Maybe<Shipping_Zones_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Shipping_Zones_Max_Fields>;
  min?: Maybe<Shipping_Zones_Min_Fields>;
  stddev?: Maybe<Shipping_Zones_Stddev_Fields>;
  stddev_pop?: Maybe<Shipping_Zones_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Shipping_Zones_Stddev_Samp_Fields>;
  sum?: Maybe<Shipping_Zones_Sum_Fields>;
  var_pop?: Maybe<Shipping_Zones_Var_Pop_Fields>;
  var_samp?: Maybe<Shipping_Zones_Var_Samp_Fields>;
  variance?: Maybe<Shipping_Zones_Variance_Fields>;
};


/** aggregate fields of "shipping_zones" */
export type Shipping_Zones_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Shipping_Zones_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Shipping_Zones_Avg_Fields = {
  __typename?: 'shipping_zones_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "shipping_zones". All fields are combined with a logical 'AND'. */
export type Shipping_Zones_Bool_Exp = {
  _and?: InputMaybe<Array<Shipping_Zones_Bool_Exp>>;
  _not?: InputMaybe<Shipping_Zones_Bool_Exp>;
  _or?: InputMaybe<Array<Shipping_Zones_Bool_Exp>>;
  countries?: InputMaybe<Countries_Bool_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "shipping_zones" */
export enum Shipping_Zones_Constraint {
  /** unique or primary key constraint */
  ShippingZonesPkey = 'shipping_zones_pkey'
}

/** input type for incrementing numeric columns in table "shipping_zones" */
export type Shipping_Zones_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "shipping_zones" */
export type Shipping_Zones_Insert_Input = {
  countries?: InputMaybe<Countries_Arr_Rel_Insert_Input>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Shipping_Zones_Max_Fields = {
  __typename?: 'shipping_zones_max_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Shipping_Zones_Min_Fields = {
  __typename?: 'shipping_zones_min_fields';
  created_at?: Maybe<Scalars['timestamp']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "shipping_zones" */
export type Shipping_Zones_Mutation_Response = {
  __typename?: 'shipping_zones_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Shipping_Zones>;
};

/** on_conflict condition type for table "shipping_zones" */
export type Shipping_Zones_On_Conflict = {
  constraint: Shipping_Zones_Constraint;
  update_columns?: Array<Shipping_Zones_Update_Column>;
  where?: InputMaybe<Shipping_Zones_Bool_Exp>;
};

/** Ordering options when selecting data from "shipping_zones". */
export type Shipping_Zones_Order_By = {
  countries_aggregate?: InputMaybe<Countries_Aggregate_Order_By>;
  created_at?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: shipping_zones */
export type Shipping_Zones_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "shipping_zones" */
export enum Shipping_Zones_Select_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "shipping_zones" */
export type Shipping_Zones_Set_Input = {
  created_at?: InputMaybe<Scalars['timestamp']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Shipping_Zones_Stddev_Fields = {
  __typename?: 'shipping_zones_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Shipping_Zones_Stddev_Pop_Fields = {
  __typename?: 'shipping_zones_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Shipping_Zones_Stddev_Samp_Fields = {
  __typename?: 'shipping_zones_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Shipping_Zones_Sum_Fields = {
  __typename?: 'shipping_zones_sum_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "shipping_zones" */
export enum Shipping_Zones_Update_Column {
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Shipping_Zones_Var_Pop_Fields = {
  __typename?: 'shipping_zones_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Shipping_Zones_Var_Samp_Fields = {
  __typename?: 'shipping_zones_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Shipping_Zones_Variance_Fields = {
  __typename?: 'shipping_zones_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

/** columns and relationships of "states" */
export type States = {
  __typename?: 'states';
  abbreviation: Scalars['String'];
  country_id: Scalars['Int'];
  created_at: Scalars['timestamp'];
  described_as?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  name: Scalars['String'];
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at: Scalars['timestamp'];
};

/** aggregated selection of "states" */
export type States_Aggregate = {
  __typename?: 'states_aggregate';
  aggregate?: Maybe<States_Aggregate_Fields>;
  nodes: Array<States>;
};

/** aggregate fields of "states" */
export type States_Aggregate_Fields = {
  __typename?: 'states_aggregate_fields';
  avg?: Maybe<States_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<States_Max_Fields>;
  min?: Maybe<States_Min_Fields>;
  stddev?: Maybe<States_Stddev_Fields>;
  stddev_pop?: Maybe<States_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<States_Stddev_Samp_Fields>;
  sum?: Maybe<States_Sum_Fields>;
  var_pop?: Maybe<States_Var_Pop_Fields>;
  var_samp?: Maybe<States_Var_Samp_Fields>;
  variance?: Maybe<States_Variance_Fields>;
};


/** aggregate fields of "states" */
export type States_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<States_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** order by aggregate values of table "states" */
export type States_Aggregate_Order_By = {
  avg?: InputMaybe<States_Avg_Order_By>;
  count?: InputMaybe<Order_By>;
  max?: InputMaybe<States_Max_Order_By>;
  min?: InputMaybe<States_Min_Order_By>;
  stddev?: InputMaybe<States_Stddev_Order_By>;
  stddev_pop?: InputMaybe<States_Stddev_Pop_Order_By>;
  stddev_samp?: InputMaybe<States_Stddev_Samp_Order_By>;
  sum?: InputMaybe<States_Sum_Order_By>;
  var_pop?: InputMaybe<States_Var_Pop_Order_By>;
  var_samp?: InputMaybe<States_Var_Samp_Order_By>;
  variance?: InputMaybe<States_Variance_Order_By>;
};

/** input type for inserting array relation for remote table "states" */
export type States_Arr_Rel_Insert_Input = {
  data: Array<States_Insert_Input>;
  /** upsert condition */
  on_conflict?: InputMaybe<States_On_Conflict>;
};

/** aggregate avg on columns */
export type States_Avg_Fields = {
  __typename?: 'states_avg_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by avg() on columns of table "states" */
export type States_Avg_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** Boolean expression to filter rows from the table "states". All fields are combined with a logical 'AND'. */
export type States_Bool_Exp = {
  _and?: InputMaybe<Array<States_Bool_Exp>>;
  _not?: InputMaybe<States_Bool_Exp>;
  _or?: InputMaybe<Array<States_Bool_Exp>>;
  abbreviation?: InputMaybe<String_Comparison_Exp>;
  country_id?: InputMaybe<Int_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  described_as?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  shipping_zone_id?: InputMaybe<Bigint_Comparison_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "states" */
export enum States_Constraint {
  /** unique or primary key constraint */
  StatesPkey = 'states_pkey'
}

/** input type for incrementing numeric columns in table "states" */
export type States_Inc_Input = {
  country_id?: InputMaybe<Scalars['Int']>;
  id?: InputMaybe<Scalars['bigint']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "states" */
export type States_Insert_Input = {
  abbreviation?: InputMaybe<Scalars['String']>;
  country_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  described_as?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type States_Max_Fields = {
  __typename?: 'states_max_fields';
  abbreviation?: Maybe<Scalars['String']>;
  country_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  described_as?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by max() on columns of table "states" */
export type States_Max_Order_By = {
  abbreviation?: InputMaybe<Order_By>;
  country_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  described_as?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** aggregate min on columns */
export type States_Min_Fields = {
  __typename?: 'states_min_fields';
  abbreviation?: Maybe<Scalars['String']>;
  country_id?: Maybe<Scalars['Int']>;
  created_at?: Maybe<Scalars['timestamp']>;
  described_as?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** order by min() on columns of table "states" */
export type States_Min_Order_By = {
  abbreviation?: InputMaybe<Order_By>;
  country_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  described_as?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** response of any mutation on the table "states" */
export type States_Mutation_Response = {
  __typename?: 'states_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<States>;
};

/** input type for inserting object relation for remote table "states" */
export type States_Obj_Rel_Insert_Input = {
  data: States_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<States_On_Conflict>;
};

/** on_conflict condition type for table "states" */
export type States_On_Conflict = {
  constraint: States_Constraint;
  update_columns?: Array<States_Update_Column>;
  where?: InputMaybe<States_Bool_Exp>;
};

/** Ordering options when selecting data from "states". */
export type States_Order_By = {
  abbreviation?: InputMaybe<Order_By>;
  country_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  described_as?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: states */
export type States_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "states" */
export enum States_Select_Column {
  /** column name */
  Abbreviation = 'abbreviation',
  /** column name */
  CountryId = 'country_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DescribedAs = 'described_as',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShippingZoneId = 'shipping_zone_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "states" */
export type States_Set_Input = {
  abbreviation?: InputMaybe<Scalars['String']>;
  country_id?: InputMaybe<Scalars['Int']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  described_as?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  shipping_zone_id?: InputMaybe<Scalars['bigint']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type States_Stddev_Fields = {
  __typename?: 'states_stddev_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev() on columns of table "states" */
export type States_Stddev_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_pop on columns */
export type States_Stddev_Pop_Fields = {
  __typename?: 'states_stddev_pop_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_pop() on columns of table "states" */
export type States_Stddev_Pop_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate stddev_samp on columns */
export type States_Stddev_Samp_Fields = {
  __typename?: 'states_stddev_samp_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by stddev_samp() on columns of table "states" */
export type States_Stddev_Samp_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate sum on columns */
export type States_Sum_Fields = {
  __typename?: 'states_sum_fields';
  country_id?: Maybe<Scalars['Int']>;
  id?: Maybe<Scalars['bigint']>;
  shipping_zone_id?: Maybe<Scalars['bigint']>;
};

/** order by sum() on columns of table "states" */
export type States_Sum_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** update columns of table "states" */
export enum States_Update_Column {
  /** column name */
  Abbreviation = 'abbreviation',
  /** column name */
  CountryId = 'country_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  DescribedAs = 'described_as',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  ShippingZoneId = 'shipping_zone_id',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type States_Var_Pop_Fields = {
  __typename?: 'states_var_pop_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_pop() on columns of table "states" */
export type States_Var_Pop_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate var_samp on columns */
export type States_Var_Samp_Fields = {
  __typename?: 'states_var_samp_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by var_samp() on columns of table "states" */
export type States_Var_Samp_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

/** aggregate variance on columns */
export type States_Variance_Fields = {
  __typename?: 'states_variance_fields';
  country_id?: Maybe<Scalars['Float']>;
  id?: Maybe<Scalars['Float']>;
  shipping_zone_id?: Maybe<Scalars['Float']>;
};

/** order by variance() on columns of table "states" */
export type States_Variance_Order_By = {
  country_id?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  shipping_zone_id?: InputMaybe<Order_By>;
};

export type Subscription_Root = {
  __typename?: 'subscription_root';
  /** fetch data from the table: "addresses" */
  addresses: Array<Addresses>;
  /** fetch aggregated fields from the table: "addresses" */
  addresses_aggregate: Addresses_Aggregate;
  /** fetch data from the table: "addresses" using primary key columns */
  addresses_by_pk?: Maybe<Addresses>;
  /** fetch data from the table: "cart_items" */
  cart_items: Array<Cart_Items>;
  /** fetch aggregated fields from the table: "cart_items" */
  cart_items_aggregate: Cart_Items_Aggregate;
  /** fetch data from the table: "cart_items" using primary key columns */
  cart_items_by_pk?: Maybe<Cart_Items>;
  /** An array relationship */
  countries: Array<Countries>;
  /** An aggregate relationship */
  countries_aggregate: Countries_Aggregate;
  /** fetch data from the table: "countries" using primary key columns */
  countries_by_pk?: Maybe<Countries>;
  /** An array relationship */
  ingredients: Array<Ingredients>;
  /** An aggregate relationship */
  ingredients_aggregate: Ingredients_Aggregate;
  /** fetch data from the table: "ingredients" using primary key columns */
  ingredients_by_pk?: Maybe<Ingredients>;
  /** An array relationship */
  recipe_bookmarks: Array<Recipe_Bookmarks>;
  /** An aggregate relationship */
  recipe_bookmarks_aggregate: Recipe_Bookmarks_Aggregate;
  /** fetch data from the table: "recipe_bookmarks" using primary key columns */
  recipe_bookmarks_by_pk?: Maybe<Recipe_Bookmarks>;
  /** fetch data from the table: "recipes" */
  recipes: Array<Recipes>;
  /** fetch aggregated fields from the table: "recipes" */
  recipes_aggregate: Recipes_Aggregate;
  /** fetch data from the table: "recipes" using primary key columns */
  recipes_by_pk?: Maybe<Recipes>;
  /** fetch data from the table: "shipping_rates" */
  shipping_rates: Array<Shipping_Rates>;
  /** fetch aggregated fields from the table: "shipping_rates" */
  shipping_rates_aggregate: Shipping_Rates_Aggregate;
  /** fetch data from the table: "shipping_rates" using primary key columns */
  shipping_rates_by_pk?: Maybe<Shipping_Rates>;
  /** fetch data from the table: "shipping_zones" */
  shipping_zones: Array<Shipping_Zones>;
  /** fetch aggregated fields from the table: "shipping_zones" */
  shipping_zones_aggregate: Shipping_Zones_Aggregate;
  /** fetch data from the table: "shipping_zones" using primary key columns */
  shipping_zones_by_pk?: Maybe<Shipping_Zones>;
  /** An array relationship */
  states: Array<States>;
  /** An aggregate relationship */
  states_aggregate: States_Aggregate;
  /** fetch data from the table: "states" using primary key columns */
  states_by_pk?: Maybe<States>;
  /** fetch data from the table: "users" */
  users: Array<Users>;
  /** fetch aggregated fields from the table: "users" */
  users_aggregate: Users_Aggregate;
  /** fetch data from the table: "users" using primary key columns */
  users_by_pk?: Maybe<Users>;
};


export type Subscription_RootAddressesArgs = {
  distinct_on?: InputMaybe<Array<Addresses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Addresses_Order_By>>;
  where?: InputMaybe<Addresses_Bool_Exp>;
};


export type Subscription_RootAddresses_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Addresses_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Addresses_Order_By>>;
  where?: InputMaybe<Addresses_Bool_Exp>;
};


export type Subscription_RootAddresses_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootCart_ItemsArgs = {
  distinct_on?: InputMaybe<Array<Cart_Items_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Cart_Items_Order_By>>;
  where?: InputMaybe<Cart_Items_Bool_Exp>;
};


export type Subscription_RootCart_Items_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Cart_Items_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Cart_Items_Order_By>>;
  where?: InputMaybe<Cart_Items_Bool_Exp>;
};


export type Subscription_RootCart_Items_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootCountriesArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Subscription_RootCountries_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Countries_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Countries_Order_By>>;
  where?: InputMaybe<Countries_Bool_Exp>;
};


export type Subscription_RootCountries_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootIngredientsArgs = {
  distinct_on?: InputMaybe<Array<Ingredients_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Ingredients_Order_By>>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};


export type Subscription_RootIngredients_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Ingredients_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Ingredients_Order_By>>;
  where?: InputMaybe<Ingredients_Bool_Exp>;
};


export type Subscription_RootIngredients_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootRecipe_BookmarksArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};


export type Subscription_RootRecipe_Bookmarks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};


export type Subscription_RootRecipe_Bookmarks_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootRecipesArgs = {
  distinct_on?: InputMaybe<Array<Recipes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipes_Order_By>>;
  where?: InputMaybe<Recipes_Bool_Exp>;
};


export type Subscription_RootRecipes_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Recipes_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipes_Order_By>>;
  where?: InputMaybe<Recipes_Bool_Exp>;
};


export type Subscription_RootRecipes_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootShipping_RatesArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Rates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Rates_Order_By>>;
  where?: InputMaybe<Shipping_Rates_Bool_Exp>;
};


export type Subscription_RootShipping_Rates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Rates_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Rates_Order_By>>;
  where?: InputMaybe<Shipping_Rates_Bool_Exp>;
};


export type Subscription_RootShipping_Rates_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootShipping_ZonesArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Zones_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Zones_Order_By>>;
  where?: InputMaybe<Shipping_Zones_Bool_Exp>;
};


export type Subscription_RootShipping_Zones_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Shipping_Zones_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Shipping_Zones_Order_By>>;
  where?: InputMaybe<Shipping_Zones_Bool_Exp>;
};


export type Subscription_RootShipping_Zones_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootStatesArgs = {
  distinct_on?: InputMaybe<Array<States_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<States_Order_By>>;
  where?: InputMaybe<States_Bool_Exp>;
};


export type Subscription_RootStates_AggregateArgs = {
  distinct_on?: InputMaybe<Array<States_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<States_Order_By>>;
  where?: InputMaybe<States_Bool_Exp>;
};


export type Subscription_RootStates_By_PkArgs = {
  id: Scalars['bigint'];
};


export type Subscription_RootUsersArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Users_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Users_Order_By>>;
  where?: InputMaybe<Users_Bool_Exp>;
};


export type Subscription_RootUsers_By_PkArgs = {
  id: Scalars['bigint'];
};

/** Boolean expression to compare columns of type "timestamp". All fields are combined with logical 'AND'. */
export type Timestamp_Comparison_Exp = {
  _eq?: InputMaybe<Scalars['timestamp']>;
  _gt?: InputMaybe<Scalars['timestamp']>;
  _gte?: InputMaybe<Scalars['timestamp']>;
  _in?: InputMaybe<Array<Scalars['timestamp']>>;
  _is_null?: InputMaybe<Scalars['Boolean']>;
  _lt?: InputMaybe<Scalars['timestamp']>;
  _lte?: InputMaybe<Scalars['timestamp']>;
  _neq?: InputMaybe<Scalars['timestamp']>;
  _nin?: InputMaybe<Array<Scalars['timestamp']>>;
};

/** columns and relationships of "users" */
export type Users = {
  __typename?: 'users';
  auth0_id?: Maybe<Scalars['String']>;
  created_at: Scalars['timestamp'];
  email?: Maybe<Scalars['String']>;
  id: Scalars['bigint'];
  name?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  /** An array relationship */
  recipe_bookmarks: Array<Recipe_Bookmarks>;
  /** An aggregate relationship */
  recipe_bookmarks_aggregate: Recipe_Bookmarks_Aggregate;
  updated_at: Scalars['timestamp'];
};


/** columns and relationships of "users" */
export type UsersRecipe_BookmarksArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};


/** columns and relationships of "users" */
export type UsersRecipe_Bookmarks_AggregateArgs = {
  distinct_on?: InputMaybe<Array<Recipe_Bookmarks_Select_Column>>;
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
  order_by?: InputMaybe<Array<Recipe_Bookmarks_Order_By>>;
  where?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
};

/** aggregated selection of "users" */
export type Users_Aggregate = {
  __typename?: 'users_aggregate';
  aggregate?: Maybe<Users_Aggregate_Fields>;
  nodes: Array<Users>;
};

/** aggregate fields of "users" */
export type Users_Aggregate_Fields = {
  __typename?: 'users_aggregate_fields';
  avg?: Maybe<Users_Avg_Fields>;
  count: Scalars['Int'];
  max?: Maybe<Users_Max_Fields>;
  min?: Maybe<Users_Min_Fields>;
  stddev?: Maybe<Users_Stddev_Fields>;
  stddev_pop?: Maybe<Users_Stddev_Pop_Fields>;
  stddev_samp?: Maybe<Users_Stddev_Samp_Fields>;
  sum?: Maybe<Users_Sum_Fields>;
  var_pop?: Maybe<Users_Var_Pop_Fields>;
  var_samp?: Maybe<Users_Var_Samp_Fields>;
  variance?: Maybe<Users_Variance_Fields>;
};


/** aggregate fields of "users" */
export type Users_Aggregate_FieldsCountArgs = {
  columns?: InputMaybe<Array<Users_Select_Column>>;
  distinct?: InputMaybe<Scalars['Boolean']>;
};

/** aggregate avg on columns */
export type Users_Avg_Fields = {
  __typename?: 'users_avg_fields';
  id?: Maybe<Scalars['Float']>;
};

/** Boolean expression to filter rows from the table "users". All fields are combined with a logical 'AND'. */
export type Users_Bool_Exp = {
  _and?: InputMaybe<Array<Users_Bool_Exp>>;
  _not?: InputMaybe<Users_Bool_Exp>;
  _or?: InputMaybe<Array<Users_Bool_Exp>>;
  auth0_id?: InputMaybe<String_Comparison_Exp>;
  created_at?: InputMaybe<Timestamp_Comparison_Exp>;
  email?: InputMaybe<String_Comparison_Exp>;
  id?: InputMaybe<Bigint_Comparison_Exp>;
  name?: InputMaybe<String_Comparison_Exp>;
  nickname?: InputMaybe<String_Comparison_Exp>;
  recipe_bookmarks?: InputMaybe<Recipe_Bookmarks_Bool_Exp>;
  updated_at?: InputMaybe<Timestamp_Comparison_Exp>;
};

/** unique or primary key constraints on table "users" */
export enum Users_Constraint {
  /** unique or primary key constraint */
  UniqAuth0User = 'uniq_auth0_user',
  /** unique or primary key constraint */
  UsersPkey = 'users_pkey'
}

/** input type for incrementing numeric columns in table "users" */
export type Users_Inc_Input = {
  id?: InputMaybe<Scalars['bigint']>;
};

/** input type for inserting data into table "users" */
export type Users_Insert_Input = {
  auth0_id?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  nickname?: InputMaybe<Scalars['String']>;
  recipe_bookmarks?: InputMaybe<Recipe_Bookmarks_Arr_Rel_Insert_Input>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate max on columns */
export type Users_Max_Fields = {
  __typename?: 'users_max_fields';
  auth0_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** aggregate min on columns */
export type Users_Min_Fields = {
  __typename?: 'users_min_fields';
  auth0_id?: Maybe<Scalars['String']>;
  created_at?: Maybe<Scalars['timestamp']>;
  email?: Maybe<Scalars['String']>;
  id?: Maybe<Scalars['bigint']>;
  name?: Maybe<Scalars['String']>;
  nickname?: Maybe<Scalars['String']>;
  updated_at?: Maybe<Scalars['timestamp']>;
};

/** response of any mutation on the table "users" */
export type Users_Mutation_Response = {
  __typename?: 'users_mutation_response';
  /** number of rows affected by the mutation */
  affected_rows: Scalars['Int'];
  /** data from the rows affected by the mutation */
  returning: Array<Users>;
};

/** input type for inserting object relation for remote table "users" */
export type Users_Obj_Rel_Insert_Input = {
  data: Users_Insert_Input;
  /** upsert condition */
  on_conflict?: InputMaybe<Users_On_Conflict>;
};

/** on_conflict condition type for table "users" */
export type Users_On_Conflict = {
  constraint: Users_Constraint;
  update_columns?: Array<Users_Update_Column>;
  where?: InputMaybe<Users_Bool_Exp>;
};

/** Ordering options when selecting data from "users". */
export type Users_Order_By = {
  auth0_id?: InputMaybe<Order_By>;
  created_at?: InputMaybe<Order_By>;
  email?: InputMaybe<Order_By>;
  id?: InputMaybe<Order_By>;
  name?: InputMaybe<Order_By>;
  nickname?: InputMaybe<Order_By>;
  recipe_bookmarks_aggregate?: InputMaybe<Recipe_Bookmarks_Aggregate_Order_By>;
  updated_at?: InputMaybe<Order_By>;
};

/** primary key columns input for table: users */
export type Users_Pk_Columns_Input = {
  id: Scalars['bigint'];
};

/** select columns of table "users" */
export enum Users_Select_Column {
  /** column name */
  Auth0Id = 'auth0_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** input type for updating data in table "users" */
export type Users_Set_Input = {
  auth0_id?: InputMaybe<Scalars['String']>;
  created_at?: InputMaybe<Scalars['timestamp']>;
  email?: InputMaybe<Scalars['String']>;
  id?: InputMaybe<Scalars['bigint']>;
  name?: InputMaybe<Scalars['String']>;
  nickname?: InputMaybe<Scalars['String']>;
  updated_at?: InputMaybe<Scalars['timestamp']>;
};

/** aggregate stddev on columns */
export type Users_Stddev_Fields = {
  __typename?: 'users_stddev_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_pop on columns */
export type Users_Stddev_Pop_Fields = {
  __typename?: 'users_stddev_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate stddev_samp on columns */
export type Users_Stddev_Samp_Fields = {
  __typename?: 'users_stddev_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate sum on columns */
export type Users_Sum_Fields = {
  __typename?: 'users_sum_fields';
  id?: Maybe<Scalars['bigint']>;
};

/** update columns of table "users" */
export enum Users_Update_Column {
  /** column name */
  Auth0Id = 'auth0_id',
  /** column name */
  CreatedAt = 'created_at',
  /** column name */
  Email = 'email',
  /** column name */
  Id = 'id',
  /** column name */
  Name = 'name',
  /** column name */
  Nickname = 'nickname',
  /** column name */
  UpdatedAt = 'updated_at'
}

/** aggregate var_pop on columns */
export type Users_Var_Pop_Fields = {
  __typename?: 'users_var_pop_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate var_samp on columns */
export type Users_Var_Samp_Fields = {
  __typename?: 'users_var_samp_fields';
  id?: Maybe<Scalars['Float']>;
};

/** aggregate variance on columns */
export type Users_Variance_Fields = {
  __typename?: 'users_variance_fields';
  id?: Maybe<Scalars['Float']>;
};

export type GetCountriesQueryVariables = Exact<{
  limit?: InputMaybe<Scalars['Int']>;
  offset?: InputMaybe<Scalars['Int']>;
}>;


export type GetCountriesQuery = { __typename?: 'query_root', countries_aggregate: { __typename?: 'countries_aggregate', aggregate?: { __typename?: 'countries_aggregate_fields', count: number } | null }, countries: Array<{ __typename?: 'countries', abbreviation?: string | null, active?: boolean | null, id: any, name?: string | null }> };

export type UpdateActiveMutationVariables = Exact<{
  id: Scalars['bigint'];
  active?: InputMaybe<Scalars['Boolean']>;
}>;


export type UpdateActiveMutation = { __typename?: 'mutation_root', update_countries_by_pk?: { __typename?: 'countries', active?: boolean | null, id: any } | null };

export type CreateProductMutationVariables = Exact<{
  productInput: CreateProductInput;
}>;


export type CreateProductMutation = { __typename?: 'mutation_root', createProduct?: { __typename?: 'CreateProductPayload', errors: Array<string>, product?: { __typename?: 'Product', id: string, name?: string | null } | null } | null };

export type GetProductsQueryVariables = Exact<{ [key: string]: never; }>;


export type GetProductsQuery = { __typename?: 'query_root', products?: Array<{ __typename?: 'Product', description?: string | null, id: string, name?: string | null, price?: number | null, quantity?: number | null, images?: Array<{ __typename?: 'Image', id: string, photoLink: string }> | null }> | null };

export type DeleteProductMutationVariables = Exact<{
  productId: Scalars['ID'];
}>;


export type DeleteProductMutation = { __typename?: 'mutation_root', deleteProduct?: { __typename?: 'DeleteProductPayload', errors: Array<string> } | null };

export type GetProductQueryVariables = Exact<{
  productId: Scalars['ID'];
}>;


export type GetProductQuery = { __typename?: 'query_root', product?: { __typename?: 'Product', id: string, description?: string | null, quantity?: number | null, price?: number | null, name?: string | null, images?: Array<{ __typename?: 'Image', id: string, photoLink: string }> | null } | null };

export type UpdateProductMutationVariables = Exact<{
  productInput: UpdateProductInput;
}>;


export type UpdateProductMutation = { __typename?: 'mutation_root', updateProduct?: { __typename?: 'UpdateProductPayload', errors: Array<string>, product?: { __typename?: 'Product', id: string, description?: string | null, name?: string | null, price?: number | null, quantity?: number | null, images?: Array<{ __typename?: 'Image', id: string, photoLink: string }> | null } | null } | null };

export type GetShippingZonesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetShippingZonesQuery = { __typename?: 'query_root', shipping_zones: Array<{ __typename?: 'shipping_zones', id: any, name: string, countries_aggregate: { __typename?: 'countries_aggregate', aggregate?: { __typename?: 'countries_aggregate_fields', count: number } | null }, countries: Array<{ __typename?: 'countries', states_aggregate: { __typename?: 'states_aggregate', aggregate?: { __typename?: 'states_aggregate_fields', count: number } | null } }> }> };

export type SettingShippingZoneMutationVariables = Exact<{
  countryIds: Array<Scalars['Int']> | Scalars['Int'];
  name: Scalars['String'];
  shippingRates: Array<ShippingRateInput> | ShippingRateInput;
}>;


export type SettingShippingZoneMutation = { __typename?: 'mutation_root', settingShippingZone?: { __typename?: 'SettingShippingZonePayload', errors: Array<string>, shippingZone?: { __typename?: 'ShippingZone', id: string } | null } | null };

export type GetCountriesNonShippingZoneQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCountriesNonShippingZoneQuery = { __typename?: 'query_root', countries: Array<{ __typename?: 'countries', id: any, name?: string | null }> };

export type DeleteShippingZoneMutationVariables = Exact<{
  id: Scalars['ID'];
}>;


export type DeleteShippingZoneMutation = { __typename?: 'mutation_root', deleteShippingZone?: { __typename?: 'DeleteShippingZonePayload', id: string } | null };

export type GetUsersQueryVariables = Exact<{ [key: string]: never; }>;


export type GetUsersQuery = { __typename?: 'query_root', users: Array<{ __typename?: 'users', email?: string | null, id: any, name?: string | null, nickname?: string | null }> };

export type BookmarkedRecipesQueryVariables = Exact<{
  searchQuery: Bigint_Comparison_Exp;
}>;


export type BookmarkedRecipesQuery = { __typename?: 'query_root', recipes: Array<{ __typename?: 'recipes', id: any, user_id?: any | null, title?: string | null, publisher?: string | null, image_url?: string | null }> };

export type AddBookmarkMutationVariables = Exact<{
  recipeId: Scalars['bigint'];
}>;


export type AddBookmarkMutation = { __typename?: 'mutation_root', insert_recipe_bookmarks_one?: { __typename?: 'recipe_bookmarks', id: any } | null };

export type DeleteBookmarkMutationVariables = Exact<{
  recipeId: Scalars['bigint'];
}>;


export type DeleteBookmarkMutation = { __typename?: 'mutation_root', delete_recipe_bookmarks?: { __typename?: 'recipe_bookmarks_mutation_response', returning: Array<{ __typename?: 'recipe_bookmarks', id: any }> } | null };

export type GetCartQueryVariables = Exact<{
  userId: Scalars['Int'];
}>;


export type GetCartQuery = { __typename?: 'query_root', cart?: { __typename?: 'Cart', id: number, subtotal: number, totalItems: number, lineItems?: Array<{ __typename?: 'LineItem', lineTotal: number, id: string, name: string, photo?: string | null, quantity: number }> | null } | null };

export type AddToCartMutationVariables = Exact<{
  productId: Scalars['Int'];
}>;


export type AddToCartMutation = { __typename?: 'mutation_root', addToCart?: { __typename?: 'AddToCartPayload', cart: { __typename?: 'Cart', id: number, subtotal: number, totalItems: number, lineItems?: Array<{ __typename?: 'LineItem', id: string, lineTotal: number, name: string, photo?: string | null, quantity: number }> | null } } | null };

export type UpdateCartQtyMutationVariables = Exact<{
  itemId: Scalars['Int'];
  adjustQty: Scalars['Int'];
}>;


export type UpdateCartQtyMutation = { __typename?: 'mutation_root', updateCartQty?: { __typename?: 'UpdateCartQtyPayload', cart: { __typename?: 'Cart', id: number, subtotal: number, totalItems: number, lineItems?: Array<{ __typename?: 'LineItem', id: string, lineTotal: number, name: string, photo?: string | null, quantity: number }> | null } } | null };

export type RemoveCartItemMutationVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type RemoveCartItemMutation = { __typename?: 'mutation_root', delete_cart_items_by_pk?: { __typename?: 'cart_items', id: any } | null };

export type ClearCartMutationVariables = Exact<{
  cartId: Scalars['Int'];
}>;


export type ClearCartMutation = { __typename?: 'mutation_root', delete_cart_items?: { __typename?: 'cart_items_mutation_response', affected_rows: number } | null };

export type GetCheckoutCountriesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetCheckoutCountriesQuery = { __typename?: 'query_root', countries: Array<{ __typename?: 'countries', id: any, name?: string | null, abbreviation?: string | null }> };

export type GetCheckoutStatesQueryVariables = Exact<{
  countryId: Scalars['Int'];
}>;


export type GetCheckoutStatesQuery = { __typename?: 'query_root', states: Array<{ __typename?: 'states', id: any, name: string }> };

export type GetShippingOptionsQueryVariables = Exact<{
  cartId: Scalars['Int'];
  countryId: Scalars['Int'];
  stateId?: InputMaybe<Scalars['Int']>;
}>;


export type GetShippingOptionsQuery = { __typename?: 'query_root', shippingOptions: Array<{ __typename?: 'ShippingOption', price?: number | null, description?: string | null, shippingRateId: string }> };

export type GetAddressesQueryVariables = Exact<{ [key: string]: never; }>;


export type GetAddressesQuery = { __typename?: 'query_root', addresses: Array<{ __typename?: 'addresses', address1?: string | null, address_type?: number | null, city?: string | null, country_id?: number | null, first_name?: string | null, id: any, is_billing_default?: boolean | null, is_default?: boolean | null, last_name?: string | null, state_id?: number | null, zip_code?: string | null, state?: { __typename?: 'states', abbreviation: string, name: string, id: any } | null }> };

export type CreateOrderMutationVariables = Exact<{
  cartId: Scalars['Int'];
}>;


export type CreateOrderMutation = { __typename?: 'mutation_root', createOrder?: { __typename?: 'CreateOrderPayload', order?: { __typename?: 'Order', id: string, number?: string | null } | null } | null };

export type CreateAddressMutationVariables = Exact<{
  address1: Scalars['String'];
  city: Scalars['String'];
  countryId: Scalars['Int'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  orderId?: InputMaybe<Scalars['Int']>;
  shoppingAddressId?: InputMaybe<Scalars['Int']>;
  stateId: Scalars['Int'];
  zipCode: Scalars['String'];
}>;


export type CreateAddressMutation = { __typename?: 'mutation_root', createAddress?: { __typename?: 'CreateAddressPayload', address?: { __typename?: 'Address', id: string } | null } | null };

export type RecipeQueryVariables = Exact<{
  id: Scalars['bigint'];
}>;


export type RecipeQuery = { __typename?: 'query_root', recipes_by_pk?: { __typename?: 'recipes', id: any, user_id?: any | null, title?: string | null, publisher?: string | null, source_url?: string | null, image_url?: string | null, servings?: number | null, cooking_time?: string | null, ingredients: Array<{ __typename?: 'ingredients', quantity?: any | null, description?: string | null, unit?: string | null }> } | null };

export type AddRecipeMutationVariables = Exact<{
  recipe: Recipes_Insert_Input;
}>;


export type AddRecipeMutation = { __typename?: 'mutation_root', insert_recipes_one?: { __typename?: 'recipes', id: any } | null };

export type SearchedRecipesQueryVariables = Exact<{
  searchQuery: String_Comparison_Exp;
}>;


export type SearchedRecipesQuery = { __typename?: 'query_root', recipes: Array<{ __typename?: 'recipes', id: any, user_id?: any | null, title?: string | null, publisher?: string | null, image_url?: string | null }> };


export const GetCountriesDocument = gql`
    query getCountries($limit: Int = 10, $offset: Int = 0) {
  countries_aggregate {
    aggregate {
      count
    }
  }
  countries(limit: $limit, offset: $offset) {
    abbreviation
    active
    id
    name
  }
}
    `;

/**
 * __useGetCountriesQuery__
 *
 * To run a query within a React component, call `useGetCountriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCountriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCountriesQuery({
 *   variables: {
 *      limit: // value for 'limit'
 *      offset: // value for 'offset'
 *   },
 * });
 */
export function useGetCountriesQuery(baseOptions?: Apollo.QueryHookOptions<GetCountriesQuery, GetCountriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCountriesQuery, GetCountriesQueryVariables>(GetCountriesDocument, options);
      }
export function useGetCountriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCountriesQuery, GetCountriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCountriesQuery, GetCountriesQueryVariables>(GetCountriesDocument, options);
        }
export type GetCountriesQueryHookResult = ReturnType<typeof useGetCountriesQuery>;
export type GetCountriesLazyQueryHookResult = ReturnType<typeof useGetCountriesLazyQuery>;
export type GetCountriesQueryResult = Apollo.QueryResult<GetCountriesQuery, GetCountriesQueryVariables>;
export const UpdateActiveDocument = gql`
    mutation updateActive($id: bigint!, $active: Boolean) {
  update_countries_by_pk(pk_columns: {id: $id}, _set: {active: $active}) {
    active
    id
  }
}
    `;
export type UpdateActiveMutationFn = Apollo.MutationFunction<UpdateActiveMutation, UpdateActiveMutationVariables>;

/**
 * __useUpdateActiveMutation__
 *
 * To run a mutation, you first call `useUpdateActiveMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateActiveMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateActiveMutation, { data, loading, error }] = useUpdateActiveMutation({
 *   variables: {
 *      id: // value for 'id'
 *      active: // value for 'active'
 *   },
 * });
 */
export function useUpdateActiveMutation(baseOptions?: Apollo.MutationHookOptions<UpdateActiveMutation, UpdateActiveMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateActiveMutation, UpdateActiveMutationVariables>(UpdateActiveDocument, options);
      }
export type UpdateActiveMutationHookResult = ReturnType<typeof useUpdateActiveMutation>;
export type UpdateActiveMutationResult = Apollo.MutationResult<UpdateActiveMutation>;
export type UpdateActiveMutationOptions = Apollo.BaseMutationOptions<UpdateActiveMutation, UpdateActiveMutationVariables>;
export const CreateProductDocument = gql`
    mutation createProduct($productInput: CreateProductInput!) {
  createProduct(input: $productInput) {
    product {
      id
      name
    }
    errors
  }
}
    `;
export type CreateProductMutationFn = Apollo.MutationFunction<CreateProductMutation, CreateProductMutationVariables>;

/**
 * __useCreateProductMutation__
 *
 * To run a mutation, you first call `useCreateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createProductMutation, { data, loading, error }] = useCreateProductMutation({
 *   variables: {
 *      productInput: // value for 'productInput'
 *   },
 * });
 */
export function useCreateProductMutation(baseOptions?: Apollo.MutationHookOptions<CreateProductMutation, CreateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateProductMutation, CreateProductMutationVariables>(CreateProductDocument, options);
      }
export type CreateProductMutationHookResult = ReturnType<typeof useCreateProductMutation>;
export type CreateProductMutationResult = Apollo.MutationResult<CreateProductMutation>;
export type CreateProductMutationOptions = Apollo.BaseMutationOptions<CreateProductMutation, CreateProductMutationVariables>;
export const GetProductsDocument = gql`
    query getProducts {
  products {
    description
    images {
      id
      photoLink
    }
    id
    name
    price
    quantity
  }
}
    `;

/**
 * __useGetProductsQuery__
 *
 * To run a query within a React component, call `useGetProductsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductsQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetProductsQuery(baseOptions?: Apollo.QueryHookOptions<GetProductsQuery, GetProductsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductsQuery, GetProductsQueryVariables>(GetProductsDocument, options);
      }
export function useGetProductsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductsQuery, GetProductsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductsQuery, GetProductsQueryVariables>(GetProductsDocument, options);
        }
export type GetProductsQueryHookResult = ReturnType<typeof useGetProductsQuery>;
export type GetProductsLazyQueryHookResult = ReturnType<typeof useGetProductsLazyQuery>;
export type GetProductsQueryResult = Apollo.QueryResult<GetProductsQuery, GetProductsQueryVariables>;
export const DeleteProductDocument = gql`
    mutation deleteProduct($productId: ID!) {
  deleteProduct(input: {id: $productId}) {
    errors
  }
}
    `;
export type DeleteProductMutationFn = Apollo.MutationFunction<DeleteProductMutation, DeleteProductMutationVariables>;

/**
 * __useDeleteProductMutation__
 *
 * To run a mutation, you first call `useDeleteProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteProductMutation, { data, loading, error }] = useDeleteProductMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useDeleteProductMutation(baseOptions?: Apollo.MutationHookOptions<DeleteProductMutation, DeleteProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteProductMutation, DeleteProductMutationVariables>(DeleteProductDocument, options);
      }
export type DeleteProductMutationHookResult = ReturnType<typeof useDeleteProductMutation>;
export type DeleteProductMutationResult = Apollo.MutationResult<DeleteProductMutation>;
export type DeleteProductMutationOptions = Apollo.BaseMutationOptions<DeleteProductMutation, DeleteProductMutationVariables>;
export const GetProductDocument = gql`
    query getProduct($productId: ID!) {
  product(id: $productId) {
    id
    description
    quantity
    price
    name
    images {
      id
      photoLink
    }
  }
}
    `;

/**
 * __useGetProductQuery__
 *
 * To run a query within a React component, call `useGetProductQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetProductQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetProductQuery({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useGetProductQuery(baseOptions: Apollo.QueryHookOptions<GetProductQuery, GetProductQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetProductQuery, GetProductQueryVariables>(GetProductDocument, options);
      }
export function useGetProductLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetProductQuery, GetProductQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetProductQuery, GetProductQueryVariables>(GetProductDocument, options);
        }
export type GetProductQueryHookResult = ReturnType<typeof useGetProductQuery>;
export type GetProductLazyQueryHookResult = ReturnType<typeof useGetProductLazyQuery>;
export type GetProductQueryResult = Apollo.QueryResult<GetProductQuery, GetProductQueryVariables>;
export const UpdateProductDocument = gql`
    mutation updateProduct($productInput: UpdateProductInput!) {
  updateProduct(input: $productInput) {
    product {
      id
      description
      name
      price
      quantity
      images {
        id
        photoLink
      }
    }
    errors
  }
}
    `;
export type UpdateProductMutationFn = Apollo.MutationFunction<UpdateProductMutation, UpdateProductMutationVariables>;

/**
 * __useUpdateProductMutation__
 *
 * To run a mutation, you first call `useUpdateProductMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateProductMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateProductMutation, { data, loading, error }] = useUpdateProductMutation({
 *   variables: {
 *      productInput: // value for 'productInput'
 *   },
 * });
 */
export function useUpdateProductMutation(baseOptions?: Apollo.MutationHookOptions<UpdateProductMutation, UpdateProductMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateProductMutation, UpdateProductMutationVariables>(UpdateProductDocument, options);
      }
export type UpdateProductMutationHookResult = ReturnType<typeof useUpdateProductMutation>;
export type UpdateProductMutationResult = Apollo.MutationResult<UpdateProductMutation>;
export type UpdateProductMutationOptions = Apollo.BaseMutationOptions<UpdateProductMutation, UpdateProductMutationVariables>;
export const GetShippingZonesDocument = gql`
    query getShippingZones {
  shipping_zones {
    id
    name
    countries_aggregate {
      aggregate {
        count
      }
    }
    countries {
      states_aggregate {
        aggregate {
          count
        }
      }
    }
  }
}
    `;

/**
 * __useGetShippingZonesQuery__
 *
 * To run a query within a React component, call `useGetShippingZonesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShippingZonesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShippingZonesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetShippingZonesQuery(baseOptions?: Apollo.QueryHookOptions<GetShippingZonesQuery, GetShippingZonesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShippingZonesQuery, GetShippingZonesQueryVariables>(GetShippingZonesDocument, options);
      }
export function useGetShippingZonesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShippingZonesQuery, GetShippingZonesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShippingZonesQuery, GetShippingZonesQueryVariables>(GetShippingZonesDocument, options);
        }
export type GetShippingZonesQueryHookResult = ReturnType<typeof useGetShippingZonesQuery>;
export type GetShippingZonesLazyQueryHookResult = ReturnType<typeof useGetShippingZonesLazyQuery>;
export type GetShippingZonesQueryResult = Apollo.QueryResult<GetShippingZonesQuery, GetShippingZonesQueryVariables>;
export const SettingShippingZoneDocument = gql`
    mutation settingShippingZone($countryIds: [Int!]!, $name: String!, $shippingRates: [ShippingRateInput!]!) {
  settingShippingZone(
    input: {countryIds: $countryIds, name: $name, shippingRates: $shippingRates}
  ) {
    errors
    shippingZone {
      id
    }
  }
}
    `;
export type SettingShippingZoneMutationFn = Apollo.MutationFunction<SettingShippingZoneMutation, SettingShippingZoneMutationVariables>;

/**
 * __useSettingShippingZoneMutation__
 *
 * To run a mutation, you first call `useSettingShippingZoneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useSettingShippingZoneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [settingShippingZoneMutation, { data, loading, error }] = useSettingShippingZoneMutation({
 *   variables: {
 *      countryIds: // value for 'countryIds'
 *      name: // value for 'name'
 *      shippingRates: // value for 'shippingRates'
 *   },
 * });
 */
export function useSettingShippingZoneMutation(baseOptions?: Apollo.MutationHookOptions<SettingShippingZoneMutation, SettingShippingZoneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<SettingShippingZoneMutation, SettingShippingZoneMutationVariables>(SettingShippingZoneDocument, options);
      }
export type SettingShippingZoneMutationHookResult = ReturnType<typeof useSettingShippingZoneMutation>;
export type SettingShippingZoneMutationResult = Apollo.MutationResult<SettingShippingZoneMutation>;
export type SettingShippingZoneMutationOptions = Apollo.BaseMutationOptions<SettingShippingZoneMutation, SettingShippingZoneMutationVariables>;
export const GetCountriesNonShippingZoneDocument = gql`
    query getCountriesNonShippingZone {
  countries(where: {shipping_zone_id: {_is_null: true}}, order_by: {id: asc}) {
    id
    name
  }
}
    `;

/**
 * __useGetCountriesNonShippingZoneQuery__
 *
 * To run a query within a React component, call `useGetCountriesNonShippingZoneQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCountriesNonShippingZoneQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCountriesNonShippingZoneQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCountriesNonShippingZoneQuery(baseOptions?: Apollo.QueryHookOptions<GetCountriesNonShippingZoneQuery, GetCountriesNonShippingZoneQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCountriesNonShippingZoneQuery, GetCountriesNonShippingZoneQueryVariables>(GetCountriesNonShippingZoneDocument, options);
      }
export function useGetCountriesNonShippingZoneLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCountriesNonShippingZoneQuery, GetCountriesNonShippingZoneQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCountriesNonShippingZoneQuery, GetCountriesNonShippingZoneQueryVariables>(GetCountriesNonShippingZoneDocument, options);
        }
export type GetCountriesNonShippingZoneQueryHookResult = ReturnType<typeof useGetCountriesNonShippingZoneQuery>;
export type GetCountriesNonShippingZoneLazyQueryHookResult = ReturnType<typeof useGetCountriesNonShippingZoneLazyQuery>;
export type GetCountriesNonShippingZoneQueryResult = Apollo.QueryResult<GetCountriesNonShippingZoneQuery, GetCountriesNonShippingZoneQueryVariables>;
export const DeleteShippingZoneDocument = gql`
    mutation deleteShippingZone($id: ID!) {
  deleteShippingZone(input: {id: $id}) {
    id
  }
}
    `;
export type DeleteShippingZoneMutationFn = Apollo.MutationFunction<DeleteShippingZoneMutation, DeleteShippingZoneMutationVariables>;

/**
 * __useDeleteShippingZoneMutation__
 *
 * To run a mutation, you first call `useDeleteShippingZoneMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteShippingZoneMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteShippingZoneMutation, { data, loading, error }] = useDeleteShippingZoneMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useDeleteShippingZoneMutation(baseOptions?: Apollo.MutationHookOptions<DeleteShippingZoneMutation, DeleteShippingZoneMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteShippingZoneMutation, DeleteShippingZoneMutationVariables>(DeleteShippingZoneDocument, options);
      }
export type DeleteShippingZoneMutationHookResult = ReturnType<typeof useDeleteShippingZoneMutation>;
export type DeleteShippingZoneMutationResult = Apollo.MutationResult<DeleteShippingZoneMutation>;
export type DeleteShippingZoneMutationOptions = Apollo.BaseMutationOptions<DeleteShippingZoneMutation, DeleteShippingZoneMutationVariables>;
export const GetUsersDocument = gql`
    query getUsers {
  users {
    email
    id
    name
    nickname
  }
}
    `;

/**
 * __useGetUsersQuery__
 *
 * To run a query within a React component, call `useGetUsersQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetUsersQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetUsersQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetUsersQuery(baseOptions?: Apollo.QueryHookOptions<GetUsersQuery, GetUsersQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetUsersQuery, GetUsersQueryVariables>(GetUsersDocument, options);
      }
export function useGetUsersLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetUsersQuery, GetUsersQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetUsersQuery, GetUsersQueryVariables>(GetUsersDocument, options);
        }
export type GetUsersQueryHookResult = ReturnType<typeof useGetUsersQuery>;
export type GetUsersLazyQueryHookResult = ReturnType<typeof useGetUsersLazyQuery>;
export type GetUsersQueryResult = Apollo.QueryResult<GetUsersQuery, GetUsersQueryVariables>;
export const BookmarkedRecipesDocument = gql`
    query bookmarkedRecipes($searchQuery: bigint_comparison_exp!) {
  recipes(where: {recipe_bookmarks: {user_id: $searchQuery}}) {
    id
    user_id
    title
    publisher
    image_url
  }
}
    `;

/**
 * __useBookmarkedRecipesQuery__
 *
 * To run a query within a React component, call `useBookmarkedRecipesQuery` and pass it any options that fit your needs.
 * When your component renders, `useBookmarkedRecipesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useBookmarkedRecipesQuery({
 *   variables: {
 *      searchQuery: // value for 'searchQuery'
 *   },
 * });
 */
export function useBookmarkedRecipesQuery(baseOptions: Apollo.QueryHookOptions<BookmarkedRecipesQuery, BookmarkedRecipesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<BookmarkedRecipesQuery, BookmarkedRecipesQueryVariables>(BookmarkedRecipesDocument, options);
      }
export function useBookmarkedRecipesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<BookmarkedRecipesQuery, BookmarkedRecipesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<BookmarkedRecipesQuery, BookmarkedRecipesQueryVariables>(BookmarkedRecipesDocument, options);
        }
export type BookmarkedRecipesQueryHookResult = ReturnType<typeof useBookmarkedRecipesQuery>;
export type BookmarkedRecipesLazyQueryHookResult = ReturnType<typeof useBookmarkedRecipesLazyQuery>;
export type BookmarkedRecipesQueryResult = Apollo.QueryResult<BookmarkedRecipesQuery, BookmarkedRecipesQueryVariables>;
export const AddBookmarkDocument = gql`
    mutation addBookmark($recipeId: bigint!) {
  insert_recipe_bookmarks_one(object: {recipe_id: $recipeId}) {
    id
  }
}
    `;
export type AddBookmarkMutationFn = Apollo.MutationFunction<AddBookmarkMutation, AddBookmarkMutationVariables>;

/**
 * __useAddBookmarkMutation__
 *
 * To run a mutation, you first call `useAddBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addBookmarkMutation, { data, loading, error }] = useAddBookmarkMutation({
 *   variables: {
 *      recipeId: // value for 'recipeId'
 *   },
 * });
 */
export function useAddBookmarkMutation(baseOptions?: Apollo.MutationHookOptions<AddBookmarkMutation, AddBookmarkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddBookmarkMutation, AddBookmarkMutationVariables>(AddBookmarkDocument, options);
      }
export type AddBookmarkMutationHookResult = ReturnType<typeof useAddBookmarkMutation>;
export type AddBookmarkMutationResult = Apollo.MutationResult<AddBookmarkMutation>;
export type AddBookmarkMutationOptions = Apollo.BaseMutationOptions<AddBookmarkMutation, AddBookmarkMutationVariables>;
export const DeleteBookmarkDocument = gql`
    mutation deleteBookmark($recipeId: bigint!) {
  delete_recipe_bookmarks(where: {recipe_id: {_eq: $recipeId}}) {
    returning {
      id
    }
  }
}
    `;
export type DeleteBookmarkMutationFn = Apollo.MutationFunction<DeleteBookmarkMutation, DeleteBookmarkMutationVariables>;

/**
 * __useDeleteBookmarkMutation__
 *
 * To run a mutation, you first call `useDeleteBookmarkMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useDeleteBookmarkMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [deleteBookmarkMutation, { data, loading, error }] = useDeleteBookmarkMutation({
 *   variables: {
 *      recipeId: // value for 'recipeId'
 *   },
 * });
 */
export function useDeleteBookmarkMutation(baseOptions?: Apollo.MutationHookOptions<DeleteBookmarkMutation, DeleteBookmarkMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<DeleteBookmarkMutation, DeleteBookmarkMutationVariables>(DeleteBookmarkDocument, options);
      }
export type DeleteBookmarkMutationHookResult = ReturnType<typeof useDeleteBookmarkMutation>;
export type DeleteBookmarkMutationResult = Apollo.MutationResult<DeleteBookmarkMutation>;
export type DeleteBookmarkMutationOptions = Apollo.BaseMutationOptions<DeleteBookmarkMutation, DeleteBookmarkMutationVariables>;
export const GetCartDocument = gql`
    query getCart($userId: Int!) {
  cart(userId: $userId) {
    id
    subtotal
    totalItems
    lineItems {
      lineTotal
      id
      name
      lineTotal
      photo
      quantity
    }
  }
}
    `;

/**
 * __useGetCartQuery__
 *
 * To run a query within a React component, call `useGetCartQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCartQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCartQuery({
 *   variables: {
 *      userId: // value for 'userId'
 *   },
 * });
 */
export function useGetCartQuery(baseOptions: Apollo.QueryHookOptions<GetCartQuery, GetCartQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCartQuery, GetCartQueryVariables>(GetCartDocument, options);
      }
export function useGetCartLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCartQuery, GetCartQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCartQuery, GetCartQueryVariables>(GetCartDocument, options);
        }
export type GetCartQueryHookResult = ReturnType<typeof useGetCartQuery>;
export type GetCartLazyQueryHookResult = ReturnType<typeof useGetCartLazyQuery>;
export type GetCartQueryResult = Apollo.QueryResult<GetCartQuery, GetCartQueryVariables>;
export const AddToCartDocument = gql`
    mutation addToCart($productId: Int!) {
  addToCart(input: {productId: $productId}) {
    cart {
      id
      lineItems {
        id
        lineTotal
        name
        photo
        quantity
      }
      subtotal
      totalItems
    }
  }
}
    `;
export type AddToCartMutationFn = Apollo.MutationFunction<AddToCartMutation, AddToCartMutationVariables>;

/**
 * __useAddToCartMutation__
 *
 * To run a mutation, you first call `useAddToCartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddToCartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addToCartMutation, { data, loading, error }] = useAddToCartMutation({
 *   variables: {
 *      productId: // value for 'productId'
 *   },
 * });
 */
export function useAddToCartMutation(baseOptions?: Apollo.MutationHookOptions<AddToCartMutation, AddToCartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddToCartMutation, AddToCartMutationVariables>(AddToCartDocument, options);
      }
export type AddToCartMutationHookResult = ReturnType<typeof useAddToCartMutation>;
export type AddToCartMutationResult = Apollo.MutationResult<AddToCartMutation>;
export type AddToCartMutationOptions = Apollo.BaseMutationOptions<AddToCartMutation, AddToCartMutationVariables>;
export const UpdateCartQtyDocument = gql`
    mutation updateCartQty($itemId: Int!, $adjustQty: Int!) {
  updateCartQty(input: {adjustQty: $adjustQty, itemId: $itemId}) {
    cart {
      id
      subtotal
      totalItems
      lineItems {
        id
        lineTotal
        name
        photo
        quantity
      }
    }
  }
}
    `;
export type UpdateCartQtyMutationFn = Apollo.MutationFunction<UpdateCartQtyMutation, UpdateCartQtyMutationVariables>;

/**
 * __useUpdateCartQtyMutation__
 *
 * To run a mutation, you first call `useUpdateCartQtyMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useUpdateCartQtyMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [updateCartQtyMutation, { data, loading, error }] = useUpdateCartQtyMutation({
 *   variables: {
 *      itemId: // value for 'itemId'
 *      adjustQty: // value for 'adjustQty'
 *   },
 * });
 */
export function useUpdateCartQtyMutation(baseOptions?: Apollo.MutationHookOptions<UpdateCartQtyMutation, UpdateCartQtyMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<UpdateCartQtyMutation, UpdateCartQtyMutationVariables>(UpdateCartQtyDocument, options);
      }
export type UpdateCartQtyMutationHookResult = ReturnType<typeof useUpdateCartQtyMutation>;
export type UpdateCartQtyMutationResult = Apollo.MutationResult<UpdateCartQtyMutation>;
export type UpdateCartQtyMutationOptions = Apollo.BaseMutationOptions<UpdateCartQtyMutation, UpdateCartQtyMutationVariables>;
export const RemoveCartItemDocument = gql`
    mutation removeCartItem($id: bigint!) {
  delete_cart_items_by_pk(id: $id) {
    id
  }
}
    `;
export type RemoveCartItemMutationFn = Apollo.MutationFunction<RemoveCartItemMutation, RemoveCartItemMutationVariables>;

/**
 * __useRemoveCartItemMutation__
 *
 * To run a mutation, you first call `useRemoveCartItemMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useRemoveCartItemMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [removeCartItemMutation, { data, loading, error }] = useRemoveCartItemMutation({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRemoveCartItemMutation(baseOptions?: Apollo.MutationHookOptions<RemoveCartItemMutation, RemoveCartItemMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<RemoveCartItemMutation, RemoveCartItemMutationVariables>(RemoveCartItemDocument, options);
      }
export type RemoveCartItemMutationHookResult = ReturnType<typeof useRemoveCartItemMutation>;
export type RemoveCartItemMutationResult = Apollo.MutationResult<RemoveCartItemMutation>;
export type RemoveCartItemMutationOptions = Apollo.BaseMutationOptions<RemoveCartItemMutation, RemoveCartItemMutationVariables>;
export const ClearCartDocument = gql`
    mutation clearCart($cartId: Int!) {
  delete_cart_items(where: {cart_id: {_eq: $cartId}}) {
    affected_rows
  }
}
    `;
export type ClearCartMutationFn = Apollo.MutationFunction<ClearCartMutation, ClearCartMutationVariables>;

/**
 * __useClearCartMutation__
 *
 * To run a mutation, you first call `useClearCartMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useClearCartMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [clearCartMutation, { data, loading, error }] = useClearCartMutation({
 *   variables: {
 *      cartId: // value for 'cartId'
 *   },
 * });
 */
export function useClearCartMutation(baseOptions?: Apollo.MutationHookOptions<ClearCartMutation, ClearCartMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<ClearCartMutation, ClearCartMutationVariables>(ClearCartDocument, options);
      }
export type ClearCartMutationHookResult = ReturnType<typeof useClearCartMutation>;
export type ClearCartMutationResult = Apollo.MutationResult<ClearCartMutation>;
export type ClearCartMutationOptions = Apollo.BaseMutationOptions<ClearCartMutation, ClearCartMutationVariables>;
export const GetCheckoutCountriesDocument = gql`
    query getCheckoutCountries {
  countries {
    id
    name
    abbreviation
  }
}
    `;

/**
 * __useGetCheckoutCountriesQuery__
 *
 * To run a query within a React component, call `useGetCheckoutCountriesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCheckoutCountriesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCheckoutCountriesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetCheckoutCountriesQuery(baseOptions?: Apollo.QueryHookOptions<GetCheckoutCountriesQuery, GetCheckoutCountriesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCheckoutCountriesQuery, GetCheckoutCountriesQueryVariables>(GetCheckoutCountriesDocument, options);
      }
export function useGetCheckoutCountriesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCheckoutCountriesQuery, GetCheckoutCountriesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCheckoutCountriesQuery, GetCheckoutCountriesQueryVariables>(GetCheckoutCountriesDocument, options);
        }
export type GetCheckoutCountriesQueryHookResult = ReturnType<typeof useGetCheckoutCountriesQuery>;
export type GetCheckoutCountriesLazyQueryHookResult = ReturnType<typeof useGetCheckoutCountriesLazyQuery>;
export type GetCheckoutCountriesQueryResult = Apollo.QueryResult<GetCheckoutCountriesQuery, GetCheckoutCountriesQueryVariables>;
export const GetCheckoutStatesDocument = gql`
    query getCheckoutStates($countryId: Int!) {
  states(where: {country_id: {_eq: $countryId}}) {
    id
    name
  }
}
    `;

/**
 * __useGetCheckoutStatesQuery__
 *
 * To run a query within a React component, call `useGetCheckoutStatesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetCheckoutStatesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetCheckoutStatesQuery({
 *   variables: {
 *      countryId: // value for 'countryId'
 *   },
 * });
 */
export function useGetCheckoutStatesQuery(baseOptions: Apollo.QueryHookOptions<GetCheckoutStatesQuery, GetCheckoutStatesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetCheckoutStatesQuery, GetCheckoutStatesQueryVariables>(GetCheckoutStatesDocument, options);
      }
export function useGetCheckoutStatesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetCheckoutStatesQuery, GetCheckoutStatesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetCheckoutStatesQuery, GetCheckoutStatesQueryVariables>(GetCheckoutStatesDocument, options);
        }
export type GetCheckoutStatesQueryHookResult = ReturnType<typeof useGetCheckoutStatesQuery>;
export type GetCheckoutStatesLazyQueryHookResult = ReturnType<typeof useGetCheckoutStatesLazyQuery>;
export type GetCheckoutStatesQueryResult = Apollo.QueryResult<GetCheckoutStatesQuery, GetCheckoutStatesQueryVariables>;
export const GetShippingOptionsDocument = gql`
    query getShippingOptions($cartId: Int!, $countryId: Int!, $stateId: Int) {
  shippingOptions(cartId: $cartId, countryId: $countryId, stateId: $stateId) {
    price
    description
    shippingRateId
  }
}
    `;

/**
 * __useGetShippingOptionsQuery__
 *
 * To run a query within a React component, call `useGetShippingOptionsQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetShippingOptionsQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetShippingOptionsQuery({
 *   variables: {
 *      cartId: // value for 'cartId'
 *      countryId: // value for 'countryId'
 *      stateId: // value for 'stateId'
 *   },
 * });
 */
export function useGetShippingOptionsQuery(baseOptions: Apollo.QueryHookOptions<GetShippingOptionsQuery, GetShippingOptionsQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetShippingOptionsQuery, GetShippingOptionsQueryVariables>(GetShippingOptionsDocument, options);
      }
export function useGetShippingOptionsLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetShippingOptionsQuery, GetShippingOptionsQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetShippingOptionsQuery, GetShippingOptionsQueryVariables>(GetShippingOptionsDocument, options);
        }
export type GetShippingOptionsQueryHookResult = ReturnType<typeof useGetShippingOptionsQuery>;
export type GetShippingOptionsLazyQueryHookResult = ReturnType<typeof useGetShippingOptionsLazyQuery>;
export type GetShippingOptionsQueryResult = Apollo.QueryResult<GetShippingOptionsQuery, GetShippingOptionsQueryVariables>;
export const GetAddressesDocument = gql`
    query getAddresses {
  addresses {
    address1
    address_type
    city
    country_id
    first_name
    id
    is_billing_default
    is_default
    last_name
    state_id
    zip_code
    state {
      abbreviation
      name
      id
    }
  }
}
    `;

/**
 * __useGetAddressesQuery__
 *
 * To run a query within a React component, call `useGetAddressesQuery` and pass it any options that fit your needs.
 * When your component renders, `useGetAddressesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useGetAddressesQuery({
 *   variables: {
 *   },
 * });
 */
export function useGetAddressesQuery(baseOptions?: Apollo.QueryHookOptions<GetAddressesQuery, GetAddressesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<GetAddressesQuery, GetAddressesQueryVariables>(GetAddressesDocument, options);
      }
export function useGetAddressesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<GetAddressesQuery, GetAddressesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<GetAddressesQuery, GetAddressesQueryVariables>(GetAddressesDocument, options);
        }
export type GetAddressesQueryHookResult = ReturnType<typeof useGetAddressesQuery>;
export type GetAddressesLazyQueryHookResult = ReturnType<typeof useGetAddressesLazyQuery>;
export type GetAddressesQueryResult = Apollo.QueryResult<GetAddressesQuery, GetAddressesQueryVariables>;
export const CreateOrderDocument = gql`
    mutation createOrder($cartId: Int!) {
  createOrder(input: {cartId: $cartId}) {
    order {
      id
      number
    }
  }
}
    `;
export type CreateOrderMutationFn = Apollo.MutationFunction<CreateOrderMutation, CreateOrderMutationVariables>;

/**
 * __useCreateOrderMutation__
 *
 * To run a mutation, you first call `useCreateOrderMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateOrderMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createOrderMutation, { data, loading, error }] = useCreateOrderMutation({
 *   variables: {
 *      cartId: // value for 'cartId'
 *   },
 * });
 */
export function useCreateOrderMutation(baseOptions?: Apollo.MutationHookOptions<CreateOrderMutation, CreateOrderMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateOrderMutation, CreateOrderMutationVariables>(CreateOrderDocument, options);
      }
export type CreateOrderMutationHookResult = ReturnType<typeof useCreateOrderMutation>;
export type CreateOrderMutationResult = Apollo.MutationResult<CreateOrderMutation>;
export type CreateOrderMutationOptions = Apollo.BaseMutationOptions<CreateOrderMutation, CreateOrderMutationVariables>;
export const CreateAddressDocument = gql`
    mutation createAddress($address1: String!, $city: String!, $countryId: Int!, $firstName: String!, $lastName: String!, $orderId: Int, $shoppingAddressId: Int, $stateId: Int!, $zipCode: String!) {
  createAddress(
    input: {address1: $address1, countryId: $countryId, default: false, firstName: $firstName, lastName: $lastName, orderId: $orderId, shoppingAddressId: $shoppingAddressId, stateId: $stateId, zipCode: $zipCode, city: $city}
  ) {
    address {
      id
    }
  }
}
    `;
export type CreateAddressMutationFn = Apollo.MutationFunction<CreateAddressMutation, CreateAddressMutationVariables>;

/**
 * __useCreateAddressMutation__
 *
 * To run a mutation, you first call `useCreateAddressMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useCreateAddressMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [createAddressMutation, { data, loading, error }] = useCreateAddressMutation({
 *   variables: {
 *      address1: // value for 'address1'
 *      city: // value for 'city'
 *      countryId: // value for 'countryId'
 *      firstName: // value for 'firstName'
 *      lastName: // value for 'lastName'
 *      orderId: // value for 'orderId'
 *      shoppingAddressId: // value for 'shoppingAddressId'
 *      stateId: // value for 'stateId'
 *      zipCode: // value for 'zipCode'
 *   },
 * });
 */
export function useCreateAddressMutation(baseOptions?: Apollo.MutationHookOptions<CreateAddressMutation, CreateAddressMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<CreateAddressMutation, CreateAddressMutationVariables>(CreateAddressDocument, options);
      }
export type CreateAddressMutationHookResult = ReturnType<typeof useCreateAddressMutation>;
export type CreateAddressMutationResult = Apollo.MutationResult<CreateAddressMutation>;
export type CreateAddressMutationOptions = Apollo.BaseMutationOptions<CreateAddressMutation, CreateAddressMutationVariables>;
export const RecipeDocument = gql`
    query Recipe($id: bigint!) {
  recipes_by_pk(id: $id) {
    id
    user_id
    title
    publisher
    source_url
    image_url
    servings
    cooking_time
    ingredients {
      quantity
      description
      unit
    }
  }
}
    `;

/**
 * __useRecipeQuery__
 *
 * To run a query within a React component, call `useRecipeQuery` and pass it any options that fit your needs.
 * When your component renders, `useRecipeQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useRecipeQuery({
 *   variables: {
 *      id: // value for 'id'
 *   },
 * });
 */
export function useRecipeQuery(baseOptions: Apollo.QueryHookOptions<RecipeQuery, RecipeQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<RecipeQuery, RecipeQueryVariables>(RecipeDocument, options);
      }
export function useRecipeLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<RecipeQuery, RecipeQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<RecipeQuery, RecipeQueryVariables>(RecipeDocument, options);
        }
export type RecipeQueryHookResult = ReturnType<typeof useRecipeQuery>;
export type RecipeLazyQueryHookResult = ReturnType<typeof useRecipeLazyQuery>;
export type RecipeQueryResult = Apollo.QueryResult<RecipeQuery, RecipeQueryVariables>;
export const AddRecipeDocument = gql`
    mutation addRecipe($recipe: recipes_insert_input!) {
  insert_recipes_one(object: $recipe) {
    id
  }
}
    `;
export type AddRecipeMutationFn = Apollo.MutationFunction<AddRecipeMutation, AddRecipeMutationVariables>;

/**
 * __useAddRecipeMutation__
 *
 * To run a mutation, you first call `useAddRecipeMutation` within a React component and pass it any options that fit your needs.
 * When your component renders, `useAddRecipeMutation` returns a tuple that includes:
 * - A mutate function that you can call at any time to execute the mutation
 * - An object with fields that represent the current status of the mutation's execution
 *
 * @param baseOptions options that will be passed into the mutation, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options-2;
 *
 * @example
 * const [addRecipeMutation, { data, loading, error }] = useAddRecipeMutation({
 *   variables: {
 *      recipe: // value for 'recipe'
 *   },
 * });
 */
export function useAddRecipeMutation(baseOptions?: Apollo.MutationHookOptions<AddRecipeMutation, AddRecipeMutationVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useMutation<AddRecipeMutation, AddRecipeMutationVariables>(AddRecipeDocument, options);
      }
export type AddRecipeMutationHookResult = ReturnType<typeof useAddRecipeMutation>;
export type AddRecipeMutationResult = Apollo.MutationResult<AddRecipeMutation>;
export type AddRecipeMutationOptions = Apollo.BaseMutationOptions<AddRecipeMutation, AddRecipeMutationVariables>;
export const SearchedRecipesDocument = gql`
    query searchedRecipes($searchQuery: String_comparison_exp!) {
  recipes(where: {title: $searchQuery}) {
    id
    user_id
    title
    publisher
    image_url
  }
}
    `;

/**
 * __useSearchedRecipesQuery__
 *
 * To run a query within a React component, call `useSearchedRecipesQuery` and pass it any options that fit your needs.
 * When your component renders, `useSearchedRecipesQuery` returns an object from Apollo Client that contains loading, error, and data properties
 * you can use to render your UI.
 *
 * @param baseOptions options that will be passed into the query, supported options are listed on: https://www.apollographql.com/docs/react/api/react-hooks/#options;
 *
 * @example
 * const { data, loading, error } = useSearchedRecipesQuery({
 *   variables: {
 *      searchQuery: // value for 'searchQuery'
 *   },
 * });
 */
export function useSearchedRecipesQuery(baseOptions: Apollo.QueryHookOptions<SearchedRecipesQuery, SearchedRecipesQueryVariables>) {
        const options = {...defaultOptions, ...baseOptions}
        return Apollo.useQuery<SearchedRecipesQuery, SearchedRecipesQueryVariables>(SearchedRecipesDocument, options);
      }
export function useSearchedRecipesLazyQuery(baseOptions?: Apollo.LazyQueryHookOptions<SearchedRecipesQuery, SearchedRecipesQueryVariables>) {
          const options = {...defaultOptions, ...baseOptions}
          return Apollo.useLazyQuery<SearchedRecipesQuery, SearchedRecipesQueryVariables>(SearchedRecipesDocument, options);
        }
export type SearchedRecipesQueryHookResult = ReturnType<typeof useSearchedRecipesQuery>;
export type SearchedRecipesLazyQueryHookResult = ReturnType<typeof useSearchedRecipesLazyQuery>;
export type SearchedRecipesQueryResult = Apollo.QueryResult<SearchedRecipesQuery, SearchedRecipesQueryVariables>;